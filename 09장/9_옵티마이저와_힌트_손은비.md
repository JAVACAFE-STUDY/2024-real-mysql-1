## 0. 들어가기 전에

MySQL에서도 쿼리를 최적으로 실행하기 위해 각 테이블의 데이터가 어떤 분포로 저장돼 있는지 통계 정보를 참조하며, 그러한 기본 데이터를 비교해 최적의 실행 계획을 수립하는 작업이 필요하다.

MySQL 서버를 포함한 대부분의 DBMS에서는 **옵티마이저**가 이러한 기능을 담당한다.

---

## 1. 개요

**[쿼리 실행 절차]**

1. 사용자로부터 요청된 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리(파스 트리)
2. SQL의 파싱 정보를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택
3. 두 번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져옴

**[옵티마이저 종류]**

-   비용 기반 최적화(Cost-based optimizer, CBO)
    -   대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립
-   규칙 기반 최적화 방법(Rule-based optimizer, RBO)
    -   쿼리를 최적화 하기 위한 여러 가지 가능한 방법을 만들고, 각 단위 작업의 비용(부하) 정보와 대상 테이블의 예측된 통계 정보를 이용해 실행 계획별 비용을 산출

---

## 2. 기본 데이터 처리

### 2-1. 풀 데이터 스캔과 풀 인덱스 스캔

풀 테이블 스캔은 인덱스를 사용하지 안혹 테이블의 데이터를 처음부터 끝까지 읽어서 요청된 작업을 처리하는 작업을 의미한다.

**[풀 스캔 테이블 선택하는 경우]**

-   테이블의 레코드 건수가 너무 작아서 인덱스를 통해 읽는 것보다 풀 테이블 스캔하는 편이 더 빠른 경우
-   WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
-   인덱스 레인지 스캔을 사용할 수 있는 쿼리라고 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우

InnoDB 스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드 (Read ahead) 작업이 자동으로 시작된다. 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측해서 요청이 오기 전에 미리 디스크에 읽어 InnoDB의 버퍼 풀에 가져다 두는 것을 의미한다.

MySQL 서버에서는 `innodb_read_ahead_threshold` 시스템 변수를 통해 InnoDB 스토리지 엔진이 언제 리드 어헤드를 시작할지 임계값을 설정할 수 있다.

리드 어헤드는 풀 테이블 스캔에서만 사용되는 것이 아니라 풀 인덱스 스캔에서도 동일하게 사용된다.

일반적으로 인덱스는 테이블의 2~3개 컬럼만으로 구성되기 때문에 테이블 자체보다는 용량이 작아서 훨씬 빠른 처리가 가능하다.

### 2-2. 병렬 처리

여기서 말하는 병렬 처리는 하나의 쿼리를 여러 스레드가 작업을 나누어 동시에 처리한다는 것을 의미한다.

병렬 처리용 스레드 개수를 아무리 늘리더라도 서버에 장착된 CPU의 코어 개수를 넘어서는 경우에는 오히려 성능이 떨어질 수도 있다.

### 2-3. ORDER BY 처리(Using filesort)

대부분의 SELECT 쿼리에서 정렬은 필수적으로 사용된다.

데이터 웨어하우스처럼 대량의 데이터를 조회해서 일괄 처리하는 기능이 아니라면 레코드 정렬 요건은 대부분의 조회 쿼리에 포함돼 있을 것이다.

**[모든 정렬을 인덱스 튜닝하기 불가능한 이유]**

-   정렬 기준이 너무 많아서 요건별로 모두 인덱스를 생성하는 것이 불가능한 경우
-   GROUP BY의 결과 또는 DISTINCT 같은 처리의 결과를 정렬해야 하는 경우
-   UNION의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
-   랜덤하게 결과 레코드를 가져와야 하는 경우

**[정렬 종류]**

-   소드 버퍼(Sort Buffer)
    -   시스템 변수 → `sort_buffer_size`
-   정렬 알고리즘
    -   싱글 패스 정렬 방식, 투 패스 정렬 방식
-   정렬 처리 방법
    -   인덱스를 사용한 정렬
    -   조인에서 드라이빙 테이블만 정렬
    -   조인에서 조인 결과를 임시 테이블로 저장 후 정렬

**[정렬 처리 방법의 성능 비교 방식]**

1. 스트리밍 방식
2. 버퍼링 방식

**[정렬 관련 상태 변수]**

`Sort_merge_passes` : 멀티 머지 처리 횟수

`Sort_range` : 인덱스 레인지 스캔을 통해 검색된 결과에 대한 정렬 작업 횟수

`Sort_scan` : 풀 테이블 스캔을 통해 검색된 결과에 대한 정렬 작업 횟수

`Sort_rows` : 지금까지 정렬한 전체 레코드 건수

### 2-4. GROUP BY

GROUP BY 또한 ORDER BY와 같이 쿼리가 스트리밍된 처리를 할 수 없게 하는 처리 중 하나다.

GROUP BY 절이 있는 쿼리에서는 HAVING 절을 사용할 수 있는데, HAVING 절은 GROUP BY 결과에 대해 필터링 역할을 수행한다.

GROUP BY 작업도 인덱스를 사용하는 경우와 그렇지 못한 경우로 나눠 볼 수 있다.

인덱스를 이용할 때는 인덱스를 차례대로 읽는 인덱스 스캔 방법과 인덱스를 건너뛰면서 읽는 루스 인덱스 스캔이라는 방법으로 나뉜다.

-   인덱스 스캔을 이용하는 GROUP BY(타이트 인덱스 스캔)
-   루스 인덱스 스캔을 이용하는 GROUP BY

### 2-5. DISTINCT 처리

DISTINCT는 집합 함수와 함께 사용되는 경우와 집합 함수가 없는 경우의 2가지로 구분한다. 각 경우 DISTINCT 키워드가 영향을 미치는 범위가 달라지기 때문이다.

-   SELECT DISTINCT …
    : MySQL 8.0부터는 GROUP BY를 수행하는 쿼리에 ORDER BY 절이 없으면 정렬을 사용하지 않는다.
-   집합 함수와 함께 사용된 DISTINCT
    : 집합 함수 내에서 사용된 DISTINCT는 그 집합 함수의 인자로 전달된 컬럼값이 유니크한 것들을 가져온다.

### 2-6. 내부 임시 테이블 활용

MySQL 엔진이 스토리지 엔진으로부터 받아온 레코드를 정렬하거나 그루핑할 때는 내부적인 임시 테이블을 사용한다.

“CREATE TEMPORARY TABLE” 명령으로 만든 임시 테이블과는 다르기 때문이다.
