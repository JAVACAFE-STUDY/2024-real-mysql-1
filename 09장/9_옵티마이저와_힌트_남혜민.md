# 개요

### 쿼리 실행 절차

1. SQL 파싱(parsing) : SQL 파서로 모듈 처리. SQL 문장을 서버가 이해할 수 있는 수준으로 분리
2. 최적화 및 실행계획 수립: 옵티마이저가 처리. SQL 파스트리를 통해 실행계획 (테이블/인덱스 등) 생성
3. 스토리지 엔진에 데이터 요청 및 처리: 실행계획에 따라 스토리지 엔진에서 데이터를 가져와 처리

### 옵티마이저의 종류

- 비용 기반 최적화(Cost-based optimization, CBO) : 최신
- 규칙 기반 최적화(Rule-based optimization, RBO) : 예전 오라클에서 사용

# 기본 데이터 처리

### 플 테이블 스캔과 풀 인덱스 스캔

- 풀 테이블 스캔: 테이블 전체를 읽어서 처리
- 풀 인덱스 스캔: 인덱스 전체를 읽어서 처리

### 병렬 처리

### ORDER BY 처리(Using filesort)

- 인덱스 이용: 인덱스를 순서대로 읽기만 하면 되서 매우 빠르나 추가/삭제 작업이 느리고 디스크 공간이 많이 필요
- Filesort 이용: 인덷스를 생성하지 않아도 돼 정렬할 레코드 많지 않으면 메모리에서 처리되어 충분히 빠름. 그러나 레코드 건수가 많아질수록 쿼리 응답 속도가 느림

#### 소트 버퍼

- 정렬을 수행하기 위해 할당 받은 별도의 메모리 공간
- 쿼리 실행 완료되면 시스템으로 반납

#### 정렬 알고리즘

- 투 패스(Two-pass)
  - 정렬 키와 레코드의 로우 아이디(row ID)만 가져와서 정렬
  - 정렬 대상 칼럼과 프라이머리 키값만 소트 버퍼에 정렬 수행하고 FK 키로 SELECT 컬럼 조회
  - 테이블을 2번 불러와야 함
  - 정렬 대상 레코드의 크기나 건수가 많을 때 효율적
- 싱글 패스(Single-pass)
  - 정렬 키와 레코드 전체를 가져와서 정렬
  - 소트 버퍼에 정렬 기준 칼럼을 포함한 SELECT 문의 칼럼을 모두 정렬 수행
  - 더 많은 소트 버전 필요
  - 최신 버전에서 주로 사용
  - 정렬 대상 레코드의 크기나 건수가 적을 때 빠른 성능을 보임

#### 정렬 처리 방법

1. 인덱스를 사용한 정렬
2. 조인에서 드라이빙 테이블만 정렬: Using filesort, 드라이빙 테이블만 검색해서 정렬을 먼저 수행하고 결과와 드리븐 테이블을 조인
3. 조인에서 조인 결과를 임시 테이블로 저장 후 정렬: Using temporary;Using filesort

**쿼리 처리 방식**

- 스트리밍: 조건 일치하는 레코드 검색되면 바로 클라에 전송. 첫 번째 레코드를 바로 전달받아 빠른 응답 시간 보장. LIMIT 으로 시간 단축 가능
  -> 인덱스를 사용한 정렬 방식
- 버퍼링: 모든 레코드를 검색하고 일괄 가공해야 함. LIMIT있어도 성능 안 됨 ex) GROUP BY, ORDER BY 등
  -> 조인에서 드라이빙 테이블만 정렬, 임시테이블을 이용한 정렬 방식

#### 정렬 관련 상태 변수

- 상태 변수: 작업의 실행 횟수 저장(정렬, 소프 버퍼 간 병합 작업 횟수 등)

### GROUP BY 처리

- 인덱스 스캔 이용하는 GROUP BY (타이트 인덱스 스캔) : 그루핑 컬럼에 인덱스가 있다면 차례로 읽어 처리
- 루스 인덱스 스캔 이용하는 GROUP BY (루스 인덱스 스캔) : 인덱스 레코드를 건너 뛰며 필요한 부분만 읽어서 가져옴 (Using index for group-by), 단일 테이블에 대한 처리만 사용 가능, 프리필스 인덱스 사용 불가, 유니크한 인덱스 수가 적을 수록 향상 = 인덱스 스킵 스캔 도입 (8.0)
- 임시 테이블 사용 방법 : 그루핑 칼럼이 인덱스를 전혀 사용 못할 때. Group by 칼럼들로 구성된 유니크 인덱스를 가진 임시테이블 만들어 가공

### DISTINCT 처리

#### 집합 함수 없는 SELECT DISTINCT ...

GROUP BY 와 동일하게 처리
SELECT 절에 사용된 DISTINCT 키워드는 조회되는 모든 칼럼의 조합이 유니크한 것을 가져옴

#### 집합 함수와 함께 사용된 DISTINCT

집합 함수에 사용된 인자의 컬럼 값이 유니크한 것을 가져와 임시 테이블 사용

### 내부 임시 테이블 활용

MySQL 엔진이 스토리지 엔진으로 받은 레코드를 정렬하거나 그루핑할 때 내부적인 임시 테이블 (Internal Temporary Table)을 사용.
메모리에 생성됐다가 테이블 크기 커지만 디스크로 이동, 쿼리 처리 완료되면 자동 삭제

#### 메모리 임시 테이블과 디스트 임시 테이블

8.0 부터 메모리는 가변길이 지원하는 TempTable, 디스크는 트랜잭션 지원 가능한 InnoDB 스토리지 엔진으로 변경됨

# 고급 최적화

### 옵티마이저 스위치 옵션

#### 네스티드 루프 조인 (Nested Loop Join)

- 두 테이블을 조인할 때 드라이빙 테이블 (가장 먼저 읽는 테이블) 레코드를 기준으로 드리븐 테이블의 일치하는 레코드를 순차적으로 읽어 조인
- 조인 연결 조건 컬럼이 인덱스에 모두 있으면 사용됨

#### MRR과 배치키 액세스 (mrr & batch_key_access)

**MRR (Multi-Range Read)**

- 드라이빙 테이블의 레코드를 드리븐 테이블과 바로 조인하지 않고 조인 버퍼에 버퍼링을하고 조인 버퍼가 가득차면 스토리지 엔진으로 한 번에 요청
- 디스크의 데이터 페이지 읽기를 최소화할 수 있음
- 인덱스 레코드를 읽을 때 여러 개의 레코드를 한 번에 읽어오는 방식

**BKA(Batched Key Access)**

- MRR 로 실행되는 조인 방식, 부가적인 정렬 작업이 필요하여 성능이 떨어질 수 있음

#### 블록 네스티드 루프 조인 (block_nested_loop)

- 네스티드 루프 조인과의 차이점 : 조인 버퍼 사용 여부, 조인에서 드라이빙과 드리븐 테이블의 순서가 다름
- 드라이빙 테이블의 레코드를 메모리에 캐시하고 드리븐 테이블과 조인
- MySQL8.0.18 부터는 해시 조인으로 변경됨

#### 인덱스 컨디션 푸시다운 (index_condition_pushdown)

- MySQL 5.6 이후부터 인덱스를 범위 제한 조건으로 사용 못해도 인덱스에 포함된 컬럼 조건이 있으면 같이모아서 스토리지 엔진에 전달할 수 있도록 핸들러 API 개선. 즉, 인덱스로 필터링까지 완료해서 테이블 읽기 수행 가능

#### 인덱스 확장(use_index_extensions)

InnoDB 스토리지 엔진을 사용하는 테이블에서 세컨더리 인덱스에 자동으로 추가된 프라이머리키 사용할 수 있도록 하는 옵션
정렬 작업에도 인덱스를 활용해서 처리 가능

#### 인덱스 머지(index_merge)

한 테이블에 2개 이상 인덱스를 이용해 쿼리 처리 할 수 있도록 하는 옵션 (일반적으로 한 인덱스로 작업 범위 줄일 수 있으면 하나의 인덱스만 사용)
쿼리의 조건이 서로 다른 인덱스를 사용하고 레코드 건수가 많은 경우 선택

1. 교집합(index_merge_intersection) : 두 인덱스의 결과를 모두 사용한 교집합으로 처리
2. 합집합(index_merge_union) : 2개 이상 조건이 인덱스를 사용하되 OR 연산자로 연결된 경우, 우선순위 큐(Priority Queue)를 이용해 중복 제거 수행
3. 정렬 후 합집합(index_merge_sort_union) : 인덱스를 사용한 후 중복 제거를 위해 강제로 정렬을 수행하고 합집합 처리

#### 세미 조인(semijoin)

다른 테이블과 실제 조인 안 하고, 조건 일치하는 레코드가 있는지 없는지만 체크하는 형태의 쿼리

**세미조인 최적화**

- 테이블 풀 아웃(Table Pull-out) : 세미 조인보다 항성 성능 좋음, 세미 조인의 서브쿼리의 테이블을 아우터 쿼리로 추출한 뒤 쿼리를 조인 쿼리로 재작성하는 형태의 최적화, 즉 서브쿼리 형태 대신 조인으로 쿼리가 재작성
- 퍼스트 매치(FirstMatch) : IN(subquery) 형태의 세미 주인을 EXIST(subquery) 형태로 변경, 서브쿼리의 결과가 하나만 필요할 때 사용하며 일치하는 첫 번째 레코드만 찾아서 처리
- 루스 스캔(LooseScan): 루스 인덱스 스캔으로 서브쿼리 테이블을 읽고 아웃터 테이블을 드리븐으로 사용하여 조인 수행
- 구체화 (Materialization): 세미 조인의 서브쿼리를 구체화하여 내부 임시 테이블을 생성해 쿼리를 최적화함
- 중복 제거 (Duplicate Weed-out): 세미 조인 서브 쿼리를 INNER JOIN 쿼리로 변경하여 실행하고 마지막 중복된 레코드를 제거

#### 컨디션 팬아웃(condition_fanout_filter)

여러 테이블이 조인되면 일치하는 레코드 건수가 적은 순서대로 조인을 싱행

#### 파생 테이블 머지(derived_merge)

파생 테이불 : FROM 절에 사용된 서브 쿼리
파생 테이블로 만든 서브쿼리를 외부 쿼리와 병항해서 서브쿼리 부분을 제거

#### 인비저블 인덱스 (use_invisible_index)

인덱스를 삭제하지 않고 비활성화 (가용 상태를 제어)시키는 옵션

#### 스킵 스캔(skip_scan)

인덱스 선행 칼럼이 조건절에 사용되지 않아도 후행 칼럼 조건으로 인덱스 쿼리 성능 개성이 가능
인덱스 순서를 무시하고 인덱스를 사용해 조인을 수행하는 방식

#### 해시 조인 (hash_join)

첫 레코드를 찾는 데 시간이 많이 걸리지만 최종 레코드를 찾는데까지 시간이 많이 안 걸림
최고 스루풋(Best Throughput) 전략에 적합, ㅔ스티드 루프 조인의 차선책
조인 조건 칼럼이 인덱스 없거나 조인 대상 테이블의 일부 레코드 건수가 매우 적을 때 사용

#### 인덱스 정렬 선호(prefer_ordering_index)

ORDER BY 를 위한 인덱스에 너무 가중치 부여하지 않도록 하는 옵션

### 조인 최적화 알고리즘

#### Exhaustive 알고리즘

5.0 이전 버전, FROM 절에 있는 테이블을 조인할 수 있는 모든 경우의 수를 조합해 가장 효율적인 방법을 찾는 방식
시간이 많이 소요됨

#### Greedy 검색 알고리즘

5.0 이후 버전, 조인 순서를 미리 정해놓고 조인을 수행하는 방식

# 쿼리 힌트

### 인덱스 힌트

옵티마이저 힌드 이전에 사용되던 기능. ANSI-SQL 표준 준수하지 못함

- STRAIGHT_JOIN : SELECT, UPDATE, DELETE 문에서 여러 테이블 조인되면 조인 순서를 고정
- USE INDEX / FORCE INDEX / IGNORE INDEX : 인덱스 사용 여부를 강제로 지정
- SQL_CALC_FOUND_ROWS : SQL_CALC_FOUND_ROWS 힌트 사용 시 해당 쿼리는 LIMIT 무시하고 끝까지 검색 수행

### 옵티마이저 힌트

**영향 범위**

- 인덱스
- 테이블
- 쿼리 블록
- 글로벌(쿼리 전체)

**종류**

- MAX_EXECUTION_TIME : 쿼리 최대 실행 시간 제한 (ms)
- SET_VAR : 세션/시스템 변수 설정
- SEMIJOIN & NO_SEMIJOIN : 세미 조인 최적화 힌트, 서브 쿼리에 명시
- SUBQUERY : 세미 조인 촤적화 사용 못할 때 이용.
- BNL & NO_BNL & HASHJOIN & NO_HASHJOIN : 조인 최적화 힌트
- JOIN_FIXED_ORDER & JOIN_ORDER & JOIN_PREFIX & JOIN_SUFFIX : 조인 순서 힌트
- MERGE & NO_MERGE : 서브쿼리를 외부 쿼리와 병합
- INDEX_MERGE & NO_INDEX_MERGE : 인덱스 병합 최적화 힌트
- NO_ICP: 인덱스 컨디션 푸시다운 최적화
- SKIP_SCAN & NO_SKIP_SCAN : 인덱스 스킵 스캔 최적화 힌트, 인덱스 선행 칼럼 없어도 인덱스 사용할 수 있도록 함, 선행 컬럼의 유니크 값이 많아지면 성능이 떨어질 수 있음
- INDEX & NO_INDEX : 인덱스 힌트 대체 용도
