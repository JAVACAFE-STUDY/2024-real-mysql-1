## 0. 들어가기 전에

MySQL의 동시성에 영향을 미치는 **잠금(Lock), 트랜잭션, 트랜잭션 격리 수준**

격리 수준은 하나의 트랜잭션 내에서 또는 여러 트랜잭션 간의 작업 내용을 어떻게 공유하고 차단할 것인지를 결정하는 레벨

---

## 1. 트랜잭션

InnoDB에서는 원자성을 지키기 때문에 트랜잭션 실패 시 롤백이 이루어진다.

DBMS에서 중요한 부분을 꼭 지킨다.

하나의 트랜잭션으로 묶어야 할 작업에 대해서 로직을 봄.

---

## 2. MySQL 엔진의 잠금

MySQL에서 사용되는 잠금은 크게 스토리지 엔진 레벨과 MySQL 엔진 레벨로 나눌 수 있다.

**2-1. 글로벌 락**

-   FLUSH 명령으로 획득
-   MySQL에서 제공하는 잠금 가운데 가장 범위가 크고, 한 세션에서 글로벌 락을 획득하면 다른 세션에서 SELECT를 제외한 대부분의 DDL, DML 문장을 실행하는 경우 해당 문장이 대기 상태
-   글로벌 락은 MySQL 서버의 모든 변경 작업을 멈춤
-   MySQL 8.0부터 InnoDB가 기본 스토리지 엔진으로 채택되면서 좀 더 가벼운 글로벌 락이 필요해졌고, Xtrabackup 이나 Enterprise Backup과 같은 백업 툴의 안정적인 실행을 위해 백업 락이 도입

**2-2. 테이블 락**

-   개별 테이블 단위로 설정되는 잠금, 명시적 또는 묵시적으로 특정 테이블의 락을 획득 할 수 있음
-   명시적인 잠금 → LOCK으로 락. UNLOCK TABLES 명령으로 잠금을 반납(해제)
-   묵시적인 잠금 → 테이블에 데이터를 변경하는 쿼리를 실행하면 발생. 쿼리가 실행되는 동안 자동으로 획득했다가 쿼리가 완료된 후 자동 해제

**2-3. 네임드 락**

-   GET_LOCK() 함수를 이용해 임의의 문자열에 대해 잠금을 설정하는 것
-   대상이 테이블, 레코드, AUTO_INCREMENT와 같은 데이터베이스 객체가 아니고, 단순히 사용자가 지정한 문자열에 대해 획득하고 반납(해제)하는 잠금

**2-4. 메타데이터 락**

-   데이터베이스 객체(테이블, 뷰, …)의 이름이나 구조를 변경하는 경우에 획득 하는 잠금

---

## 3. InnoDB 스토리지 엔진 잠금

**[InnoDB 스토리지 엔진의 잠금]**

레코드 기반의 잠금 기능을 제공하며, 잠금 정보가 상당히 작은 공간으로 관리되기 때문에 레코드 락이 페이지 락으로, 또는 테이블 락으로 레벨업되는 경우(락 에스컬레이션)는 없다.

일반 상용 DBMS와는 다르게 InnoDB 스토리지 엔진에서는 레코드 락뿐 아니라 레코드와 레코드 사이의 간격을 잠그는 **갭 락**이라는 것이 존재한다.

![스크린샷 2024-10-17 오후 8.30.46.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/9f0c08f1-728e-42d2-bbf3-345b741ebfc9/dbb9291e-7738-4aa1-adaf-e047d1de34be/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-10-17_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_8.30.46.png)

**[락 종류]**

-   레코드 락 : 레코드 자체만을 잠금
-   갭 락 : 레코드와 인접한 레코드 사이의 간격을 잠금
-   넥스트 키 락 : 레코드 락과 갭 락을 합쳐 놓은 형태의 잠금
-   자동 증가 락 : 내부적으로 `AUTO_INCREMENT` 락이라고 하는 테이블 수준의 잠금

\*\* InnoDB의 잠금은 레코드를 잠그는 것이 아니라 인덱스를 잠그는 방식으로 처리된다. 즉, 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 락을 걸어야 한다.

---

### 4. MySQL의 격리 수준

트랜잭션의 격리 수준(isolation level) 이란 여러 트랜잭션이 동시에 처리도리 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지를 결정하는 것이다.

**[3가지 부정합 문제]**

| DIRTY READ      | NON-REPEATABLE READ | PHANTOM READ |
| --------------- | ------------------- | ------------ |
| READ UNCOMMITED | 발생                | 발생         |
| READ COMMITED   | 없음                | 발생         |
| REPEATABLE READ | 없음                | 없음         |
| SERIALIZABLE    | 없음                | 없음         |

** 일반적인 온라인 서비스 용도의 데이터베이스는 **`READ COMMITED`**와 **`REPEATABLE READ`\*\* 중 하나를 사용한다.

\*\* 오라클 같은 DBMS에서는 주로 READ COMMITED 수준을 많이 사용하고, MySQL에서는 READTABLE READ를 주로 사용한다.

**[격리 수준 종류]**

**4-1. READ UNCOMMITTED**

-   변경 내용이 COMMIT이나 ROLLBACK 여부에 상관 없이 다른 트랜잭션에서 보임

**4-2. READ COMMITTED**

-   더티 리드 같은 현상은 발생하지 않고, 어떤 트랜잭션에서 데이터를 변경했더라도 COMMIT이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있다.
-   일반적인 웹 프로그램에서는 크게 문제되지 않을 수 있지만, 하나의 트랜잭션에서 동일 데이터를 여러 번 읽고 변경하는 작업이 금전적인 처리와 연결되면 문제가 될 수 있다.

**4-3. REPEATABLE READ**

-   InnoDB 스토리지 엔진에서 기본으로 사용되는 격리 수준
-   바이너리 로그를 가진 MySQL 서버에서는 최소 REPETABLE READ 격리 수준 이상을 사용해야 함

**4-4. SERIALIZABLE**

-   가장 단순한 격리 수준이면서 동시에 가장 엄격한 격리 수준
-   동시성 처리 성능도 무조건 떨어짐
-   한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서는 절대 접근할 수 없다.
