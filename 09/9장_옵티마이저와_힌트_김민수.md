## 개요

쿼리를 최적으로 실행하기 위해 각 테이블의 데이터가 어떤 분포로 저장되어 있는지 통계 정보를 참조하며,

그러한 기본 데이터를 비교해 최적의 실행 계획을 수립하는 작업이 필요하다.

대부분의 DBMS에서는 '옵티마이저'가 이러한 기능을 담당한다.

쿼리의 실행 계획을 수립하는 옵티마이저는 가장 복잡한 부분으로 알려져 있다.

### 쿼리 실행 절차

MySQL 서버에서 쿼리가 실행되는 과정은 크게 아래 세단계로 나눠진다.

1. 사용자로부터 요청된 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리(파스 트리)한다.

- 옵티마이저의 종류
    - 규칙 기반 최적화 : 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고, 우선순위에 따라 실행 계획을 수립하는방식 이미 오래전부터 많은 DBMS에서 거의 사용하지 않는다.
    - 비용 기반 최적화 : 산출된 실행 방법별로 비용이 최소로 소요되는 처리 방식을 선택해 최종적으로 쿼리를 실행한다. 대부분의 RDBMS가 채택하고 있는 방식이며, MySQL 도 마찬가지다.

## 기본 데이터 처리

### 풀 테이블 스캔과 풀 인덱스 스캔

풀 테이블 스캔은 인덱스를 사용하지 않고, 테이블의 데이터를 처음부터 끝까지 읽어서 요청된 작업을 처리하는 작업

- 테이블의 레코드 수가 너무 적을 때
- 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
- 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우

### 병렬 처리

병렬처리 ? 하나의 쿼리를 여러 스레드가 작업을 나누어 동시에 처리한다는 것

MySQL 8.0 버전에서는 아무런  WHERE 조건 없이 단순히 테이블의 전체 건수를 가져오는 쿼리만 병렬 처리할 수 있다.

### ORDER BY 처리(Using filesort)

- 인덱스 이용
    - 장점 : 이미 인덱스가 정렬돼 있어서 매우 빠르다
    - 단점 :
        - INSERT, UPDATE, DELETE 작업 시 부가적인 인덱스 추가/삭제 작업이 필요하므로 느리다.
        - 인덱스 때문에 디스크 공간이 더 많이 필요하다
- Filesort 이용
    - 장점 :
        - 인덱스를 생성하지 않아도 됨
        - 정렬해야 할 레코드가 많지 않으면 충분히 빠르다
    - 단점 : 쿼리 실행시 정렬 작업이 실행되므로 건수가 많아질수롣 쿼리의 응답 속도가 느리다.
        
        모든 정렬을 인덱스를 이용하도록 튜닝하기란 거의 불가능하다.
        
        - 정렬 기준이 너무 많아서 요건별로 모두 인덱스를 생성하는 것이 불가능한 경우
        - GROUP BY의 결과 또는 DISTINCT 같은 처리의 결과를 정렬해야하는 경우
        - UNION의 결과와 같이 임시 테이블의 결과를 다시 정렬해야하는 경우
        - 랜덤하게 결과 레코드를 가져와야 하는 경우

## 고급 최적화

MySQL 옵티마이저는 실행 계획을 수립할 때 통계 정보와 옵티마이저 옵션을 결합해서 최적의 실행 계획을 수립한다. 
여기서 옵티마이저 옵션을 크게 조인과 관련된 옵티마이저 옵션과 옵티마이저 스위치로 구분할 수 있다.

### 옵티마이저 스위치 옵션
- 옵티마이저 스위치 옵션은 optimizer_switch 시스템 변수를 이용해서 제어한다.

## 쿼리 힌트 

옵티마이저가 부족한 실행계획을 수립할 떄가 있는데, 이럴 때 옵티마이저에게 쿼리의 실행 계획을 어떻게 수립해야 할 지 알려줄 방법이 필요한데 이걸
쿼리 힌트라고 부른다.

- 인덱스 힌트
- 옵티마이저 힌트
