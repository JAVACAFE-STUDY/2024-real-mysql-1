# 4장 아키텍처

## 1. MySQL 서버 엔진 아키텍처

### MySQL 아키텍처 전체 구조

- 프로그램API(WAS) -> MYSQL 엔진 -> 스토리지 엔진 -> 운영체제(데이터 파일, 로그 파일)

### MySQL 엔진

- 머리 역할
    - SQL 문장 분석 , 최적화
- 대부분의 작업을 처리함
- 종류
    1. 커넥션 핸들러
    2. 인터페이스
    3. 파서
    4. 옵티마이저
    5. 캐시 & 버퍼

### 스토리지 엔진

- 손발 역할
    - 디스크에 데이터 IO 작업
- 마지막 데이터 읽기/쓰기 작업 처리
- 종류
    1. InnoDB (현재 기본)
    2. MyISAM (5.5 버전 이전 기본)
    3. Memory

### Handler API

- MySQL 엔진과 스토리지 엔진이 서로 소통할때 사용하는 요청 api
    - 확인 명령어
        ```
      show global status like 'handler%'
       ```

### MySQL 스레딩 구조

- MySQL 은 프로세스가 아닌 스레드 기반으로 작동한다
- **포그라운드 스레드(클라이언트 스레드)**
    - MySQL 서버에 접속된 클라이언트의 수만큼 존재함
    - 사용자의 쿼리 문장을 처리한다
    - 읽기 작업을 주로 처리한다
    - 데이터 버퍼나 캐시까지만 처리하고 나머지 디스크 작업은 백그라운드 스레드가 처리함
- **백그라운드 스레드**
    - 하는일
        - 인서트 버퍼 병합
        - 로그를 디스크로 기록
        - innoDB 버퍼 풀의 데이터를 디스크에 기록
        - 데이터를 버퍼로 읽어옴
        - 잠금이나 데드락을 모니터링
    - 쓰기 작업을 전담하며 읽기 작업은 포그라운드 스레드에서도 담당하므로 읽기 쓰레드보다 쓰기 쓰레드 개수를 더 많이 설정해야한다
        - 쓰기 작업은 지연 처리가 가능하지만 읽기 작업은 즉시 읽어야 하므로 쓰기 작업은 버퍼 일괄 처리 기능이 있음.

### 메모리 할당 및 사용 구조

- 글로벌 메모리 영역(스레드들 끼리 공유 하는 영역) / 로컬 메모리 영역

1. **글로벌메모리 영역**

- 하나의 메모리 영역으로만 할당 된다
- 모든 스레드가 공유한다
- 종류
    1. 테이블 캐시
    2. innoDB 버퍼 풀
    3. InnoDB 어댑티브 해시 인덱스
    4. InnoDB 리두(redo) 로그 버퍼

2. **로컬 메모리영역(세션 메모리 영역)**
    - 클라이언트 스레드가 쿼리를 처리하는데 사용하는 메모리 영역(서버에 존재)
    - 클라이언트 당 독립적으로 사용되며 절대 공유되지 않음.
    - 종류
        1. 정렬 버퍼
        2. 조인 버퍼
        3. 바이너리 로그 캐시
        4. 네트워크 버퍼

#### 플러그인 스토리지 엔진 모델

- 직접 만들수 있는 스토리지 엔진
- 사용되지 않는 스토리지 엔진을 사용하려면 서버를 껐다 켜야 되는데 플러그인 형태는 라이브러리를 다운해서 넣기만 하면 사용 할 수 있다.

### 컴포넌트

- 플러그인의 단점을 보완함.

### 쿼리 실행 구조

1. 쿼리 파서
    - 사용자 쿼리를 트리 형태의 구조로 만들어냄
2. 전처리기
    - 구조적인 문제점이 았는지 확인 -> 쿼리 유효성 확인, 인증 정보 확인
3. 옵티마이저
    - 실행 비용 최적화
4. 실행엔진
    - 손발 역할. 핸들러에게 요청해 다시 넘기는 역할을함
5. 핸들러(스토리지 엔진)
    - 디스크 IO 작업
6. 복제

### 쿼리 캐시

- 성능상 단점으로 8.0부터 사라짐

### 스레드 풀

### 트랜잭션 지원 메타 데이터

- 권한 등 기본 테이블이 트랜잭션을 지원하는 InnoDB 스토리지 엔진에 저장 됨.

## 2. InnoDB 스토리지 엔진 아키텍처

- 스토리지 엔진 중 유일하게 레코드 기반 잠금을 제공한다.

### 프라이머리 키 클러스터링

- innoDB 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링 되어 저장된다.
    - 즉, 프라이머리 키 순서대로 디스크에 저장됨
    - 다른 인덱스에 비해 비중이 높음
    - 오라클의 IOT와 동일한 구조가 InnoDB 에서는 일반적인 테이블 구조가 되는 것.

### 외래 키 지원

- 외래키는 InnoDB 스토리지 엔진 레벨에서 지원하는 기능으로 MyISAM 이나 MEMORY 테이블에서는 사용할 수 없다.
- 외래키 제약 검사를 해야되기 때문에 데드락 가능성 up, 약간의 성능 하락이 있음. 해당 설정은 시스템 변수 설정으로 끌 수 있음

### MVCC

- 잠금을 사용하지 않는 일관된 읽기
- 하나의 레코드에 여러 버전이 동시에 관리 됨.
- 언두 영역에 커밋 전 데이터를 보관해 다른 트랜잭션이 읽을때 대신 반환해줌
- 트랜잭션 + 커넥션이 많아 질수록 언두 영역 공간 스페이스가 많앙질 수 있다.

### 잠금 없는 일관된 읽기

- InnoDB 는 MVCC 를 이용해 잠금을 걸지 않고 읽기(select) 작업을 수행함.
- 순수한 select 작업은 다른 트랜잭션의 변경 작업와 관계없이 항상 잠금을 대기하지 않고 바로 실행됨.

### 자동 데드락 감지

- 주기적으로 데드락 감지 스레드가 데드락을 찾아서 그 중 하나를 강제로 중지함.
- 강제 중지 기준: 언두 로그양이 더 적은 레코드를 롤백함
- 해당 설정도 키고 끌 수 있음

### 자동화된 장애 복구

- 기본적으로 장애 복구를 자동으로 함. 복구 모드로 복구 옵션을 지정할 수 있음

### InnoDB 버퍼 풀

- InnoDB 스토리지 엔진에서 가장 핵심적인 부분.
- 크게 두가지 역할
    - 데이터 파일, 인덱스 정보를 메모리에 캐시함.
    - 쓰기 작업을 지연시켜 일괄 함.

1. 버퍼 풀의 크기 설정
    - 전체 메모리의 50% 정도만 할당해서 조금씩 올리는 걸 권장함.
    - 버퍼풀은 128MB 바이트 청크 단위로 쪼개어 관리 됨.
    - 버퍼풀 인스턴스는 기본적으로 8개로 초기화 됨. (128MB * 8 = 1GB)
    - 메모리가 1GB 미만일땐 1개로 초기화됨 (메모리 크기에 따라 유동적으로 달라짐)
2. 버퍼풀의 구조
    - 메모리 공간을 페이지 크기의 조각으로 쪼개여 페이지 조각에 저장함. (페이징)
    - 페이징 기능을 위해 3가지 자료 구조를 사용함
        1. LRU(Least Recently Used) 리스트 (가장 최근 사용)
           - 한번 읽어온 페이지를 최대한 오랫동안 버퍼풀에 올려 디스크 읽기를 최소화 하는 것.
           - 얼마나 최근에 접근했었는지에 따라 Age가 부여되고 해당 페이지는 버퍼 풀에서 제거 됨.
        2. 플러시(flush) 리스트
           - 동기화 되지 않은 데이터를 가진 페이지 (더티 페이지) 
           - 데이터 변경이 일어나면 플러시 리스트에 기록됐다가 데이터에 적재된다.
        3. 프리(free) 리스트 : 비어있는 페이지 목록. 새롭게 데이터 페이지를 읽어와야하는 경우 사용됨
    - 버퍼풀 메모리 공간을 크게 키울 수록 캐싱 성능이 향상된다. 버퍼링 기능은 관련 없다.
3. 버퍼 풀과 리두 로그
   - 버퍼풀의 버퍼링기능을 향상시키려면 리두 로그를 관리해야 한다.
4. 버퍼 풀 플러시
   - 성능 하락을 막기 위해 2개의 플러시 기능을 백그라운드로 실행한다
      1. 플러시 리스트 플러시
         - 너무 많이 쌓이면 성능에 영향이 가기 때문에 주기적으로 오래된 데이터부터 플러시함
         - 어댑티드 플러시 알고리즘을 사용하면 알아서 풀 사이즈를 바꿔줌 (기본으로 사용 됨)
      2. LRU 리스트 플러시
         - 사용하지 않는 데이터들을 제거해 공간을 만드는 역할
5. 버퍼 풀 상태 백업 및 복구
   - 버퍼풀에 워밍업 되었을 때와 아닐때 성능차이는 10배까지도 난다
   - 5.6버전부터 버퍼풀 덤프 기능이 추가 돼 현재 버퍼 풀 상태를 백업 할 수 있다.
   - 시스템 설정에서 버퍼풀 자동 복구 옵션을 켤 수 있다. 
6. 버퍼풀 적재 내용 확인
   - 관련 테이블에서 select 문 으로 확인 가능함.

### Double Write Buffer
- 백업용 버퍼로 기록에 실패했을 때만 사용 됨. 
- 성능이 정말 중요한 경우 비활성화 하는 게 좋음

### 언두 로그
- 변경되기 이전 버전을 저장하는 데이터
- 격리 수준을 보장하기 위해 쓰인다
    - 트랜잭션 롤백 대비
- 언두로그는 데이터 변경되는 크기만큼 늘어날 수 있으므로 성능에 영향이 갈 수 있음 
- 언두 테이블 스페이스

### 체인지 버퍼
- 변경해야할 인덱스 페이지가 있을 버퍼풀에 없을 때 미리 사용자에게 값을 반환하고 추후 처리하기 위해 필요한 임시 공간

### 리두 로그 및 로그 버퍼
- 거의 모든 DB는 쓰기보다 읽기 성능을 더 고려하기 때문에 파일 쓰기는 디스크의 랜덤 액세스가 필요함.


### 어댑티브 해시 인덱스
- B-Tree 검색시간을 줄여주기 위해 도입된 기능임.
- 버퍼풀에 있는 데이터 검색을 빠르게 만들어주는 기능이기 때문에 디스크에서 읽어와야 하는 경우가 많은 경우에는 성능이 좋지 않음.
- 삭제 변경 작업 성능은 좋지 않음
- 상태를 봐서 쓰는게 좋음

### InnoDB와 MyISAM, MEMORY 스토리지 엔진 비교
- 5.5버전부터 InnoDB 등장, 8버전 부턴 모든 테이블 InnoDB 스토리지 엔진 사용. 나머지는 없어지는 추세

## 3. MyISAM 스토리지 엔진 아키텍처

### 키 캐시
- 버퍼풀과 비슷한 역할을 하지만 인덱스만을 대상으로 작동함.

## 4. MySQL 로그 파일
### 에러 로그 파일
1. 시작 과정에 관련한 정보성 에러 메시지
2. 비정상 종료 관련한 트랜잭션 복구 메세지 
3. 쿼리 처리 도중에 발생하는 에러 메세지
4. 비정상적으로 종료된 커넥션 메세지
5. 모니터링 상태 또는 조회 명령 결과 메세지
6. MySQL 종료 메시지

### 제너럴 쿼리 로그 파일 
- 실행했던 쿼리 내용이 에러 여부와 관계 없이 모두 기록됨
- 슬로우 쿼리 로그(느린 쿼리 잡기)와 다르게 바로 기록 됨

### 슬로우 쿼리 로그
- 쿼리 실행후 기록하기 때문에 쿼리가 정상적으로 완료 되어야 기록 됨 
- 로그파일을 분석해 통계나 랭킹을 낼 수 있음
