# MySQL 엔진 아키텍처

#### MySQL 엔진

- 커넥션 핸들러
- SQL 파서 및 전처리기
- 옵티마이저

#### 스토리지 엔진

실제 데이터를 스토리지에 저장하거나 읽는 처리 수행

#### 핸들러 API

MySQL 엔진과 스토리지 엔진 사이에서 데이터 주고받는 역할

### MySQL 스레딩 구조 (커뮤니티 에디션)

MySQL 서버는 스레드 기반 작동

#### 포그라운드 스레드 (클라이언트 스레드)

접속된 클라이언트 수만큼 존재.
커넥션 종료하면 다시 스레드 캐시로 돌아감
일정 개수의 스레드만 존재하도록 스레드 캐시 관리
데이터를 MySQL 데이터 버퍼나 캐시로 가져오고 없는 경우 디스크 데이터나 인덱스 파일로 읽어와서 처리
MyISAM 테이블 : 디스크 쓰기까지 포그라운드가 처리, InnoDB 테이블은 데이터 버퍼나 캐시만 포그라운드 처리

#### 백그라운드 스레드

InnoDB

- 인서트 버퍼 병합
- 로그를 디스크로 기록
- InnoDB 버퍼 풀 데이터를 디스크에 기록
- 데이터를 버퍼로 로드
- 잠금이나 데드락 모니터링

### 메모리 할당 및 사용 구조

#### 글로벌 메모리 영역

- 테이블 캐시
- InnoDB 버퍼 풀
- InnoDB 어댑티브 해시 인덱스
- InnoDB 리두 로그 버퍼

#### 로컬 메모리 영역

- 정렬 버퍼(Sort buffer)
- 조인 버퍼
- 바이너리 로그 캐시
- 네트워크 버퍼

### 플러그인 스토리지 엔진 모델

스토리지 엔진 와 인증이나 전문 검색 파서, 쿼리 재작성 플러그인 있음

### 컴포넌트

플러그인 단점

- MySQL 서버와 인터페이스 할 수 있고 플러그인 끼리 통신 불가
- 캡술화 안됨
- 초기화 어려움

### 쿼리 실행 구조

#### 쿼리 파서

사용자 요청의 쿼리를 토큰으로 분리해 트리 구조로 만드는 작업

#### 전처리기

파서 트리로 쿼리 문자에 문제 있는지 확인

#### 옵티마이저

쿼리 문장을 저렴하고 빠르게 처리할지 결정

#### 실행 엔진

핸들러에게 요청해서 받은 결과를 다른 핸들러 요청으로 연결

#### 핸들러(스토리지 엔진)

디스크로 데이터 저장하고 읽어오는 역할

#### 복제

#### 쿼리 캐시

SQL 실행 결과를 메모리에 캐시하고 동일한 결과는 즉시 반환
그러나 MySQL 8.0 에서 제거됨

#### 스레드 풀

### 트랜잭션 지원 메타 데이터

데이터베이스 서버에서 테이블 구조 정보 등을 담는 데이터 딕셔너리 or 메타데이터
MySQL 8.0 부터 InnoDB 테이블에 저장

# InnoDB 스토리지 엔진 아키텍처

레코드 기반의 잠금을 제공
높은 동시성 처리 가능, 안정적이며 성능이 뛰어남

### 프라이머리 키에 의한 클러스터링

모든 테이블은 PK를 기준으로 클러스터링되어 저장
PK 값 순서대로 디스크에 저장, 모든 세컨더리 인덱스는 PK 값으로 논리적인 주소 사용

### 외래 키 지원

외래키: 부모 테이블, 지식 테이블 모두 인덱스 생성 필요, 변경 시에는 데이터 체크 작업 필요

### MVCC (Multi-Version Concurrency Control)

레코드 레벨의 트랜잭션 지원
InnoDB는 언두 로그를 이용해 구현
한 레코드에 대해 여러 버전이 유지되고 필요에 따라 (격리수준 등) 데이터 결과가 다르게 보여진다

- 멀티 버전(Multi-Version): 한 레코드에 여러 버전이 동시에 관리

### 잠금 없는 일관된 읽기 (Non-Locking Consistent Reads)

잠금을 걸지 않고, 읽기 작업을 수행
격리수준이 SERIALIZABLE이 아닌 경우에만 순수한 읽기 작업 (타 트랜잭션 변경 작업과 무관하게 항상 잠금을 하지 않고 바로 실행)
변경 전 데이터를 읽기 위해 언드로그 사용

### 자동 데드락 감지

잠금 대기 목록을 그래프(Wait-For List) 형태로 관리해 데드락 감지
데드락 감지 스레드가 주기적으로 검사해 교착 상태에 빠진 트랜잭션들을 찾아 (일반적으로) 언두 로그가 더 적은 것을 강제 종료
동시 처리 스레드가 매우 많거나 트랜잭션의 잠금 개수가 많아지면 데드랑 감지 스레드가 느려짐 -> CPU 사용량 증가

### 자동화된 장애 복구

MySQL 서버가 시작될 때 항상 자동 복구를 수행

### InnoDB 버퍼 풀의

디스크 데이터 파잉이나 인덱스 정보를 메모리에 캐시
쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있는 버퍼 역할; 여러 곳에 위치한 레코드를 변경할 때 생기는 랜덤 디스크 작업을 모아서 처리

#### 버퍼 풀의 크기 설정

OS와 클라이언트의 스레드의 메모리 등을 고려해 설정

- 레코드 버퍼: 세션에서 레코드 읽고 쓸 때 사용하는 버퍼 공간

> [처음 설정시 권장하는 버퍼풀 크기!]
> OS 8GB 미만: 50%를 버퍼 풀로 설정
> OS 8GB 이상: 50%부터 올려서 최적점 설정

버퍼 풀 크기 줄이는 작업은 서비스 영향이 크므로 주의 (권장 X)
세마포어(버퍼 풀을 여러 작은 버퍼풀로 쪼개지며 개별 버퍼 풀 전체를 관리하는 잠금) 이 경헙을 분산되는 효과를 줌

#### 버퍼 풀 구조

큰 메모리 공간을 페이지 크기로 쪼개어 데이터 페이지를 읽어서 각 조각에 저장

- LRU(Least Recently Used) 리스트: 페이지를 읽거나 쓸 때마다 리스트의 맨 앞으로 이동
  - LRU + MRU(Most Recently Used) 리스트가 결함된 형태: LRU 리스트의 맨 뒤에 MRU 리스트를 두어 최근에 사용된 페이지를 빠르게 찾을 수 있게 함
  - 처음 읽힌 데이터 페이지는 자주 사용되면 MRU에 계속 살아있고, 사용되지 않으면 LRU 끝으로 밀려나 버퍼풀에서 제거
- 플러스(Flush) 리스트: 동기화되지 않은 데이터 페이지 (더티 페이지)의 변경 시점 기준 페이지 목록을 관리
  - 변경된 페이지를 디스크로 기록할 때 사용, 리두 로그에 기록하고 데이터 페이지도 변경 내용 반영
- 프리(Free) 리스트: 비어 있는 페이지의 목록, 새로운 페이지를 읽어올 때 사용

InnoDB 스토리지 엔진은 체크포인트를 발생시켜 디스크 리두로그와 데이터 페이지 상태를 동기화
체크포인트: MySQL 서버 실행시 리두 로그의 어느 부분부터 복구를 할지 기준점을 만듦

#### 버퍼 풀과 리두 로그

데이터 변경이 계속 있으면 리두 로그 파일의 로그 엔트리를 덮어씀
전체 리두 로그 파일 에서 재생 불가능한 공간을 활동 리두로그라고 함

#### 버퍼 풀 플러시(Buffer Pool Flush)

버퍼 풀에서 디스크에 기록되지 않은 더티 페이지들을 디스크로 동기화하는 작업

- 플러스 리스트 플러시 함수: 플러시 리스트에서 오래전 변경 데이터 페이지 순서대로 디스크에 기록
- 클리너 스레드: 더티 페이지를 디스크로 동기화하는 스레드, 하나의 클리너 스레드가 하나의 버퍼 풀 인스턴스 처리하도록 자동으로 변경
- 어댑티브 플러시(Adaptive Flush): 버퍼 풀이 얼마나 더티 페이지를 가지고 있는지에 따라 플러시 작업을 수행하는 방식, 리두 로그 증가 속도에 따라 더티 페이지가 버퍼풀에 유지되도록 디스크 쓰기 실행
- LRU 리스트 플러스 함수: LRU 리스트에서 사용 빈도 낮은 데이터 페이지 제거하여 공간을 만들 때 사용

#### 버퍼 풀 상태 백업 및 복구

- 수동 복구: 버퍼 풀 덤프 및 적개 기능
- MySQL 서버 셧다운 직전에 버퍼풀 백업 실행, 서버 시작하면 자동으로 백업된 버퍼풀 상태를 복구하는 기능 제공

### Double Write Buffer

- 파셜 페이지(Partial Page) 또는 톤 페이지 (Torn-page): 페이지가 일부만 기록되는 현상

Double Write Buffer: 재시작시 Double Write 버퍼 내용과 데이터 파일 페이지를 비교해 다르면 Double Write 버퍼 내용을 데이터 파일페이지로 복사

### 언두 로그

언두로그(Undo Log): 트랜잭션과 격리 수준 보장을 위해 DML로 변경하기 이전 데이터를 별도로 백업한 데이터

- 트랜잭션 롤백 대비용, 트랜잭션 격리수준 유지하며 높은 동시성 제공

#### 언두로그 기능

- 언두 로그 레코드 모니터링
- 언두 데이블 스페이스 관리: 언두가 저장되는 공간

### 체인지 버퍼

체인지 버퍼(Change Buffer): 인덱스 페이지에 대한 변경 작업을 버퍼에 저장해 놓고 나중에 일괄 처리할 때 사용하는 임시 메모리 공간

### 리두 로그 및 로그 버퍼

리두로그: 트랜잭션 4요소 ACID 중 D(영속성)을 보장하기 위해 사용
서버가 비정상종료됐을 때 파일에 기록 못한 데이터 잃지 않게 해줌

#### 리두 로그 아카이빙

리두 로그 엔트리 중 일부를 디스크에 기록하는 작업

#### 리드로그 활성화 및 비활성화

항상 활성화되어, 트랜잭션 커밋돼도 데이터 파일은 디스크 동기화 안 되지만 리두로그(트랜잭션 로그)는 항상 디스크로 기록 -> 특정 시점의 일관된 데이터 상태를 유지

### 어댑티브 해시 인덱스(Adaptive Hash Index)

InnoDB 버퍼 풀에 캐시된 데이터 페이지를 읽을 때 사용하는 인덱스
B-Tree 인덱스보다 빠르게 데이터 페이지를 찾을 수 있음 - 데이터 페이지의 키값으로 해시 인덱스를 만들고 필요 시 어댑티스 해시 인덱스로 검색

# MyISAM 스토리지 엔진 아키텍처

### 키 캐시(Key Cache, 키 버퍼)

InnoDB 버퍼풀과 유사한 역할
인덱스만을 대상으로 작동
인덱스 디스크 쓰기 작업에서만 부분적으로 버퍼링 역할

### 운영체제의 캐시 및 버퍼

테이블 읽기 및 쓰기 작업은 OS의 디스크 읽기 및 쓰기 작업을 사용

### 데이터 파일과 프라이머리 키 (인덱스) 구조

데이터 파일이 힙(Heap) 공간처럼 활용 - 프라이머리 키값과 무관하게 INSERT 순서대로 데이터 파일에 저장. 프라이머리키와 세컨더리 인덱스는 ROWID라는 물리적 주솟값을 포인터로 가짐


# MySQL 로그 파일

### 에러 로그 파일

실행 중 발생하는 에러나 경고 메시지가 출력되는 로그 파일
my.cnf/log_error 파라미터로 정의된 경로에 생성. 별로 경로가 없으면 datadir에 .err 로 생성

- MySQL의 시작과정의 정보성 및 에러 메시지
- 마지막 종료가 비정상적인 경우 나타나는 InnoDB의 트랜잭션 복구 메시지
- 쿼리 처리 중 발생한 문제 에러 메시지
- 비정상적으로 종료된 커넥션 메시지(Aborted connection)
- InnoDB 모니터링 또는 상태 조회 명령(SHOW ENGINE INNODB STATUS)의 결과 메시지
- MySQL의 종료 메시지

### 제너럴 쿼리 로그 파일 (제너럴 로그파일, General Log)

실행되기 전 MySQL이 쿼리 요청 받으면 기록하여 쿼리 실행 중 에러 있어도 로그 파일에 기록됨

### 슬로우 쿼리 로그

정상적으로 실행 완료되고 실행 시간이 long_query_time 보다 큰 쿼리를 기록하는 로그 파일
파일/테이블로 저장 가능

- 슬로우쿼리 통계
- 실행빈도 및 누적 실행 시간순 랭킹
- 쿼리별 실행 횟수 및 누적 실행 시간 상세 정보

