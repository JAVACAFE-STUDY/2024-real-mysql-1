# 디스크 읽기 방식

### 하드 디스크 드라이브(HDD) 와 솔리드 스테이트 드라이브(SSD) 의 차이점

데이터 베이스 서버에서 순차 I/O는 비중이 크기 않음
랜덤 I/O로 작은 데이터 읽고 쓰기 작업이 대부분임

따라서 SSD 의 장점이 잘 드러남

### 랜덤 I/O와 순차 I/O

디스크 성능: 얼마나 많은 데이터를 한 번에 기록하느냐에 따라 결정
여러 번 쓰기 또는 읽기 요청하는 랜덤 I/O는 성능 저하를 가져옴

# 인덱스란?

인덱스 크기가 비대해지면 역효과를 불러옴

- 프라이머리 키 : 레코드를 대표하는 컬럼의 값으로 식별자의 역할을 하는 인덱스. NULL 값, 중복이 허용되지 않음
- 보조키 (세컨더리 인덱스) : 프라이머리 키를 제외한 나머지 인덱스. 유니크 인덱스 (프라이머리키와 비슷하고 대체가능, 대체 키)

인덱스 알고리즘

- B-Tree 인덱스: 가장 일반적인 인덱스 알고리즘. 칼럼 값을 변형하지 않고 원래 값을 이용해 인덱싱
- Hash 인덱스: 컬럼값으로 해시값을 계산하여 인덱싱. 빠른 검색을 지원하나 전방 일치나 범위검색에서는 사용 불가. 메모리 기반의 테이블에서 많이 사용

# B-Tree 인덱스 (Balanced Tree)

### 구조 및 특성

- 루트 노드
- 브랜치 노드
- 리프 노드: 실제 데이터 파일 레코드의 주소값을 가지고 있음

인덱스 키 값은 정렬. 데이터 파일 레코드는 임의의 순서
InnoDB 테이블은 프라이머리키를 주소처럼 사용하여 논리적인 주소를 가짐
InnoDB 스토리지 엔진에선 모든 세컨더리 인덱스 검색에서 프라이머리 키를 저자하는 B-Tree를 다시 검색

### B-Tree 인덱스의 키 추가 및 삭제

#### 인덱스 키 추가

상대적으로 쓰기 작업에 비용이 많이 듦. 인덱스 페이지를 읽고 쓰기해야 해서 시간이 걸림

#### 인덱스 키 삭제

인덱키 삭제로 인한 마킹 작업 역시 디스크 i/O가 필요하므로 시간이 걸림

#### 인덱스 키 변경

기존 인덱스 키 값 삭제 후 새로운 키 추가하는 형태로 처리. 체인지 버퍼를 활용해 지연 처리 가능

#### 인덱스 키 검색

트리 탐색을 통해 검색. 루트 노드부터 시작해 리프 노드까지 이동하며 검색
함수나 연산의 수행 결과로 정렬 또는 검색은 B-Tree 인덱스의 장점을 잉요할 수 없음

### B-Tree 인덱스 사용에 영향을 미치는 요소

- 인덱스 키 값의 크기: 키 값 크기 증가 -> 메모리 캐시할 레코드 수 감소 -> 디스크 읽기 증가 -> 시가나 더 거림
- B-Tree 의 깊이: 깊이가 늘어날 수록 디스크 읽기 증가, 검색 시간 증가
- 선택도(Selectivity) = 기수성 (Cardinality, 카디널리티) : 인덱스 키 값 중 유니크한 값의 수. 선택도가 높을 수록 검색 대상이 줄어들어 빠르게 처리
- 읽어야 하는 레코드 건수: 전체 테이블 레코드의 20~25% 초과하는 경우 인덱스 대시ㅣㄴ 필터링 방식이 더 효율적

### B-Tree 인덱스를 통한 데이터 읽기

#### 인덱스 레인지 스캔

1. 인덱스 탐색(Index seek): 인덱스에서 조건 만족하는 값이 저장된 위치 탐색
2. 인덱스 스캔(Index scan): 조건에 맞는 인덱스 레코드를 순차적으로 읽음
3. 2번 과정에서 읽은 인덱스 키와 레코드 주소를 이용해 실제 데이터 레코드를 읽음

#### 인덱스 풀스캔

인덱스의 처음부터 끝까지 모두 읽는 방식
쿼리 조건절의 컬럼이 인덱스 첫 번째 칼럼이 아닌 경우 사용

#### 루스 인덱스 스캔

느슨하게 또는 듬성듬성하게 인덱스를 읽음. 중간에 필요치 않은 인덱스 키는 넘어감

#### 인덱스 스킵 스캔

인덱스 선행 컬럼의 유니크한 값 개수가 소량일 때만 적용 가능한 최적화

### 다중 칼럼(Multi-Column) 인덱스

두 개 이상의 칼럼으로 구성된 인덱스
인덱스 내 컬럼의 위치(순서) 중요

# R-Tree 인덱스

공간 인덱스로 2차원 데이터를 인덱싱할 때 사용

### 구조 및 특성

MBR(Minimum Bounding Rectangle) : 데이터를 포함하는 가장 작은 사각형 (POINT, LINE, POLYGON 포함)

- 루트노드 : 최상위 MBR
- 브랜치 노드 : 차상위 MBR
- 리프 노드 : 개가 도형의 객체

# 전문 검색 인덱스 (Full Text Index)

문서 전체에 대한 분석과 검색을 위한 인덱스 알고리즘

### 인덱스 알고리즘

- 어근 분석 알고리즘: 검색어 단어의 뿌리 원형을 찾는 과정, 형태소 분석
- n-gram 알고리즘: 본문을 무조건 몇 글자씩 잘라 인덱싱
- 불용어 변경 및 삭제
  - 전문 검색 인덱스의 불용어 처리 무시
  - 사용자 저의 불용어 사용

### 전문 검색 인덱스의 가용성

- 쿼리 문장에 전문 검색을 위한 문법 (MATCH AGAINST) 사용
- 테이블이 전문 인덱스 보유

# 함수 기반 인덱스

칼럼 값을 변형하여 만든 값을 이용해 인덱싱

- 가상 칼럼을 이용한 인덱스: 테이블에 새 컬럼 추가하는 효과가 나타나, 실 테이블 구조가 변경된다는 단점
- 함수를 이용한 인덱스: 테이블 구조 변경대시니 계산한 결과 값의 검색을 빠르게 함. 조건 절에 함수 기반 인덱스에 명시된 표현식 그대로 사용

# 멀티 밸류 인덱스 (Multi-Value Index)

하나의 데이터 레코드가 여러 개 키 가질 수 있는 형태의 인덱스

# 클러스터링 인덱스

클러스터링: 테이블 레코드를 프라이머리 키를 기준으로 저장

### 클러스터링 인덱스

- 장점
  - 프라이머리 키 기반의 검색이 빠름
  - 모든 세컨더리 인덱스가 프라이머리 키를 가지고 있어 인덱스만으로 처리할 수 있는 경우가 많음
- 단점
  - 레코드 저장이나 프라이머리 키 변경이 상대적으로 느림
  - 전체적으로 인덱스 크기가 커짐

### 클러스터링 인덱스 사용 시 주의사항

-클러스터링 인덱스 키 크기: 인덱스 커지면 메모리 더 필요함

- 프라이머리 키 AUTO-INCREMENT 보다는업무적인 칼럼으로 생성
- 프라이머리 키 무조건 명시

# 유니크 인덱스

NULL 2개 이상 저장 가능
프라이머리 키는 NULL 허용 안 하는 유니크 속성 자동 부여

### 유니크 인덱스와 일반 세컨더리 인덱스의 비교

읽기: 성능상 거의 영향이 없음. 유니크하지 않은 세컨더리 인덱스의 읽기는 읽어야 할 레코드가 많아서 느린 것.
쓰기: 유니크하지 않은 세컨더리 인덱스의 쓰기보다 느림

### 유니크 인덱스 사용 시 주의사항

유일성이 보장되어야 하면 유니크 인덱스 생성
꼭 필요하지 않으면 유니크하지 않은 세컨더리 인덱스 생성

# 외래키

InnoDB 스토리지 엔진에서만 생성

- 테이블 변경(쓰기 자금) 발생하는 경우에만 잠금 결합(잠금 대기)방생
- 외래키와 연관안 된 칼럼의 변경은 최대한 잠금 결합(잠금 대기) 발생하지 않음

자식 테이블 외레키 칼럼의 변경 시 부모 테이블 레코드에 쓰기 자금 있으면 해당 작업 해제할 때까지 대기
물리적인 외래키 고려사항: 연관 테이블에 읽기 잠금을 걸어야 하므로 쿼리 동시 처리에 영향을 미침
