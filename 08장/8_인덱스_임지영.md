# 8장 인덱스
## 1. 디스크 읽기 방식
- 데이터 저장 매체(SSD,HDD...)는 컴퓨터에서 가장 느린 부분임
- I/O를 어떻게 줄이느냐가 DB 성능 튜닝의 관건이 된다

### 하드 디스크 드라이브(HDD) 솔리드 스테이트 드라이브(SSD)
- SSD 와 HDD의 차이점
    - SSD 의 랜덤 읽기 성능이 HDD보다 훨씬 빠르다

### 랜덤 IO 와 순차 IO 
- 순차 IO 가 랜덤 IO 보다 빠르다
  - 순차 IO 가 랜덤 IO 보다 훨씬 빨리 많은 레코드를 읽어 올 수 있다.
- 인덱스 레인지 스캔은 데이터를 읽기 위해 주로 랜덤 IO를 사용한다
- 풀 테이블 스캔은 순차 IO를 사용한다 

## 2. 인덱스란?
- DB는 SortedList 처럼 데이터를 항상 정렬된 상태로 유지한다.
  - 저장할 때는 느리지만 읽을때는 빨라진다 
- 인덱스는 insert, update, delete 성능을 희생하고 select 성능을 높이는 것이다.
- 어떤 알고리즘을 쓰냐, 유니크 인덱스냐 아니냐에 따라 성능 차이가 난다. 

## 3. B-Tree 인덱스 
- Balanced Tree
- 가장 먼저 도입되고 일반적으로 사용되는 인덱스
- 칼럼의 원래 값을 변형시키지 않고 항상 정렬된 상태로 유지 시킴

### 구조 및 특성
- 최상위 루트 노드가 1개 존재하고, 자식 노드가 붙어 있는 형태
- 가장 하위 노드는 리프 노드이며, 중간 노드들은 브랜치 로드라고 불린다.
- 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값(=InnoDB에서 ROWID는 PK) 을 가지고 있다.
- 데이터 파일 자체는 정렬되어있지 않다. 
  - insert만 있으면 순서대로 저장하지만 중간에 삭제가 생기면 빈공간을 다시 채우기 때문임.
- 세컨더리 인덱스부터는 데이터를 찾고나서 주소값을 찾기 위해 pk 인덱스를 다시 한번 탐색한다. (InnoDB 특징)

### B-Tree 인덱스 키 추가 및 삭제
1. 인덱스 키 추가
   - 새로운 키 값이 저장될때 새로운 키값이 즉시 인덱스에 저장되는게 아님
   - 리프 노드가 꽉 차서 새로운 리프 노드가 필요한 경우 상위 브랜치까지 작업을 해야해서 비용이 늘어나게 됨.
     => 체인지 버퍼로 지연 처리 함. 
   - 유니크 인덱스의 경우에는 중복 체크가 필요하기 때문에 즉시 추가하거나 삭제함
   - 🔥해당 작업은 디스크 작업이지 메모리나 CPU 작업이 아님
2. 인덱스 키 삭제 
   - B-Tree 리프 노드만 찾아서 삭제 마킹함.
   - 삭제 된 공간은 그대로 방치하거나 재활용 될 수 있음. 
3. 인덱스 키 변경
   - 수정이 아닌 삭제 후 추가 작업이 일어남.
4. 인덱스 키 검색 
   - B-Tree 인덱스는 루트 노드부터 시작해서 리프 노드까지 탐색하면서 데이터를 찾아감.
   - select 에서만 사용하는 게 아니라 Update 나 delete를 처리하기 찾을 때도 위해서도 사용됨
   - 100% 일치 또는 데이터 앞부분 일치, 부등호 검색의 경우에 사용할 수 있다
   - 뒷부분으로는 찾을 수 없다.
   - 키에 변형이 가해진 이후에는 사용할 수 없다. 
   - 인덱스에 따라 테이블 갭락 범위 결정되므로 update나 delete 시 적절한 인덱스가 없으면 성능이 떨어질 수 있다.

### B-Tree 인덱스 사용에 영향을 미치는 요소 
- 인덱스를 구성하는 컬럼의 크기, 레코드 건수, 유니크 인덱스 키 값의 개수 등이 영향을 미친다.
1. 인덱스 키 값의 크기
   - 인덱스는 페이지 단위로 관리 된다. 
   - 페이지는 기본적으로 16kb 기준으로 관리 된다 (시스템 변수로 4kb~64kb 설정 가능)
   - 인덱스 키 값이 클 수록 페이지에 담을수 있는 데이터는 줄어들기 때문에 성능이 떨어진다.
2. B-Tree 깊이
   - 직접 제어할 방법은 없음.
   - 깊이 만큼 제곱 연산됨
   - 아무리 대용량이라도 5뎁스 이상 가는 경우는 없음
3. 선택도(기수성)
   - 유니크한 값의 수를 의미함. (분포도)
   - 중복 값이 없을 수록 검색 대상이 줄어들기 때문에 더 빠르게 처리 됨
4. 읽어야 할 레코드의 개수 
   - 읽어들여야할 레코드의 개수가 전체 레코드 개수의 20~25% 이상이면 풀스캔 후 필터링 하는 게 더 이득임
   - 인덱스는 그냥 읽는것보다 4~5배 정도 자원을 소모함.

### B-Tree 인덱스를 통한 데이터 읽기
1. 인덱스 레인지 스캔 
   - 가장 대표적은 스캔 방식이며 빠른 방법이다
   - 인덱스의 첫번째 키 값과 마지막 키 값 사이의 데이터를 읽는 방식
2. 인덱스 풀 스캔
   - 인덱스의 모든 키 값을 읽는 방식
   - 인덱스의 크기가 작을 때 사용하면 빠르게 처리할 수 있다.
3. 루스 인덱스 스캔 
   - 듬성 듬성하게 인덱스를 읽음. 
   - group by, max(), min() 함수일 때 사용함
4. 인덱스 스킵 스캔
   - 다중 인덱스가 걸려있더라도 우선 조건을 같이 넣어서 쿼리를 최적화해 인덱스를 최적화해 실행함. 
   - 선행 컬럼의 유니크한 값 개수가 적어야 성능이 나옴
5. 다중 컬럼 인덱스
   - 여러개 컬럼의 인덱스를 같이 검

### B-Tree 인덱스의 정렬 및 스캔 방향
1. 인덱스의 정렬
   1. 인덱스 스캔 방향
      - 알아서 처리함
   2. 내림차순 인덱스
