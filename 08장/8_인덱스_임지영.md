# 8장 인덱스
## 1. 디스크 읽기 방식
- 데이터 저장 매체(SSD,HDD...)는 컴퓨터에서 가장 느린 부분임
- I/O를 어떻게 줄이느냐가 DB 성능 튜닝의 관건이 된다

### 하드 디스크 드라이브(HDD) 솔리드 스테이트 드라이브(SSD)
- SSD 와 HDD의 차이점
    - SSD 의 랜덤 읽기 성능이 HDD보다 훨씬 빠르다

### 랜덤 IO 와 순차 IO 
- 순차 IO 가 랜덤 IO 보다 빠르다
  - 순차 IO 가 랜덤 IO 보다 훨씬 빨리 많은 레코드를 읽어 올 수 있다.
- 인덱스 레인지 스캔은 데이터를 읽기 위해 주로 랜덤 IO를 사용한다
- 풀 테이블 스캔은 순차 IO를 사용한다 

## 2. 인덱스란?
- DB는 SortedList 처럼 데이터를 항상 정렬된 상태로 유지한다.
  - 저장할 때는 느리지만 읽을때는 빨라진다 
- 인덱스는 insert, update, delete 성능을 희생하고 select 성능을 높이는 것이다.
- 어떤 알고리즘을 쓰냐, 유니크 인덱스냐 아니냐에 따라 성능 차이가 난다. 

## 3. B-Tree 인덱스 
- Balanced Tree
- 가장 먼저 도입되고 일반적으로 사용되는 인덱스
- 칼럼의 원래 값을 변형시키지 않고 항상 정렬된 상태로 유지 시킴

### 구조 및 특성
- 최상위 루트 노드가 1개 존재하고, 자식 노드가 붙어 있는 형태
- 가장 하위 노드는 리프 노드이며, 중간 노드들은 브랜치 로드라고 불린다.
- 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값(=InnoDB에서 ROWID는 PK) 을 가지고 있다.
- 데이터 파일 자체는 정렬되어있지 않다. 
  - insert만 있으면 순서대로 저장하지만 중간에 삭제가 생기면 빈공간을 다시 채우기 때문임.
- 세컨더리 인덱스부터는 데이터를 찾고나서 주소값을 찾기 위해 pk 인덱스를 다시 한번 탐색한다. (InnoDB 특징)

### B-Tree 인덱스 키 추가 및 삭제
1. 인덱스 키 추가
   - 새로운 키 값이 저장될때 새로운 키값이 즉시 인덱스에 저장되는게 아님
   - 리프 노드가 꽉 차서 새로운 리프 노드가 필요한 경우 상위 브랜치까지 작업을 해야해서 비용이 늘어나게 됨.
     => 체인지 버퍼로 지연 처리 함. 
   - 유니크 인덱스의 경우에는 중복 체크가 필요하기 때문에 즉시 추가하거나 삭제함
   - 🔥해당 작업은 디스크 작업이지 메모리나 CPU 작업이 아님
2. 인덱스 키 삭제 
   - B-Tree 리프 노드만 찾아서 삭제 마킹함.
   - 삭제 된 공간은 그대로 방치하거나 재활용 될 수 있음. 
3. 인덱스 키 변경
   - 수정이 아닌 삭제 후 추가 작업이 일어남.
4. 인덱스 키 검색 
   - B-Tree 인덱스는 루트 노드부터 시작해서 리프 노드까지 탐색하면서 데이터를 찾아감.
   - select 에서만 사용하는 게 아니라 Update 나 delete를 처리하기 찾을 때도 위해서도 사용됨
   - 100% 일치 또는 데이터 앞부분 일치, 부등호 검색의 경우에 사용할 수 있다
   - 뒷부분으로는 찾을 수 없다.
   - 키에 변형이 가해진 이후에는 사용할 수 없다. 
   - 인덱스에 따라 테이블 갭락 범위 결정되므로 update나 delete 시 적절한 인덱스가 없으면 성능이 떨어질 수 있다.

### B-Tree 인덱스 사용에 영향을 미치는 요소 
- 인덱스를 구성하는 컬럼의 크기, 레코드 건수, 유니크 인덱스 키 값의 개수 등이 영향을 미친다.
1. 인덱스 키 값의 크기
   - 인덱스는 페이지 단위로 관리 된다. 
   - 페이지는 기본적으로 16kb 기준으로 관리 된다 (시스템 변수로 4kb~64kb 설정 가능)
   - 인덱스 키 값이 클 수록 페이지에 담을수 있는 데이터는 줄어들기 때문에 성능이 떨어진다.
2. B-Tree 깊이
   - 직접 제어할 방법은 없음.
   - 깊이 만큼 제곱 연산됨
   - 아무리 대용량이라도 5뎁스 이상 가는 경우는 없음
3. 선택도(기수성)
   - 유니크한 값의 수를 의미함. (분포도)
   - 중복 값이 없을 수록 검색 대상이 줄어들기 때문에 더 빠르게 처리 됨
4. 읽어야 할 레코드의 개수 
   - 읽어들여야할 레코드의 개수가 전체 레코드 개수의 20~25% 이상이면 풀스캔 후 필터링 하는 게 더 이득임
   - 인덱스는 그냥 읽는것보다 4~5배 정도 자원을 소모함.

### B-Tree 인덱스를 통한 데이터 읽기
1. 인덱스 레인지 스캔 
   - 가장 대표적은 스캔 방식이며 빠른 방법이다
   - 인덱스의 첫번째 키 값과 마지막 키 값 사이의 데이터를 읽는 방식
2. 인덱스 풀 스캔
   - 인덱스의 모든 키 값을 읽는 방식
   - 인덱스의 크기가 작을 때 사용하면 빠르게 처리할 수 있다.
3. 루스 인덱스 스캔 
   - 듬성 듬성하게 인덱스를 읽음. 
   - group by, max(), min() 함수일 때 사용함
4. 인덱스 스킵 스캔
   - 다중 인덱스가 걸려있더라도 우선 조건을 같이 넣어서 쿼리를 최적화해 인덱스를 최적화해 실행함. 
   - 선행 컬럼의 유니크한 값 개수가 적어야 성능이 나옴
5. 다중 컬럼 인덱스
   - 여러개 컬럼의 인덱스를 같이 검

### B-Tree 인덱스의 정렬 및 스캔 방향
1. 인덱스의 정렬
   1. 인덱스 스캔 방향
      - 알아서 처리함
   2. 내림차순 인덱스
      - 정순 인덱스가 역순 인덱스보다 성능 25%정도 좋음
      - 어차피 인덱스 걸리는건 똑같음. 
      - 빈번도에 따라 고려하면 좋음

### B-Tree 인덱스의 가용성과 효율성
1. 비교 조건의 종류와 효율성 (< , > )
   - 다중 컬럼 인덱스의 경우 = 조건이 먼저 오는게 당연히 효율성 높음
2. 인덱스의 가용성
   - %like 검색은 인덱스 안탐
   - 다중 컬럼에서 후속 조건만 검색하면 인덱스 안탐
3. 효율성 안좋은 경우 -> 인덱스 안 태움
   1. non-equal 조건
   2. %like 
   3. 함수 거는 경우
   4. 타입이 안맞는 경우
   
## 4. R-Tree 인덱스
- 공간 데이터를 다루는 인덱스 (2차원)
- Rectangle Tree

### R-Tree 인덱스의 용도
- 위,경도 좌표 검색시
  - 현 위치에서 5km 범위 검색 등

## 5. 전문 검색 인덱스
- B-Tree 인덱스 걸때 큰 데이터 컬럼을 인덱스 걸면 데이터를 3072바이트로 잘라서 인덱스화 함
- 전문 검색 인덱스는 전문 검색 엔진을 사용해야함

### 인덱스 알고리즘 
1. 어근 분석 알고리즘 
   - 불용어 처리
   - 키거나 끌 수 있음
2. n-gram 알고리즘 
   - 단어를 n개씩 끊어서 인덱싱
### 전문 검색 인덱스의 가용성
1. 다음 두가지 조건을 갖춰야함 
   - select 시 match() against()  예약어 사용
   - 대상 컬럼에 전문 인덱스 보유 (FULLTEXT INDEX)

## 6. 함수 기반 인덱스
### 가상 컬럼 인덱스
- 가상컬럼은 테이블에 새로운 컬럼을 추가하는 거랑 똑같은 효과임
### 함수를 이용한 인덱스
- 새로운 컬럼을 추가시키지 않고 함수 결과를 바탕으로 인덱스를 만듦
- 함수가 조금만 달라져도 못씀 

## 7. 멀티 밸류 인덱스
- JSON 타입만을 대상으로 배열 값 인덱스를 걸 수 있음

## 8. 클러스터링 인덱스 
- 클러스터링: 여러개를 하나로 묶는 다는 의미
### 클러스터링 인덱스
- 프라이머리 키에만 적용 됨.
- PK 키에 의해서 저장 위치가 결정 됨
- PK 키 값이 바뀌면 저장 위치가 아예 바뀌어 버림  
- PK 키가 없는 경우 임의로 PK 키 대체 컬럼을 생성함
  - not null 유니크 인덱스 중 첫번째를 고름
  - 자동 증가 컬럼을 내부적으로 추가해 클러스터링 키로 선택함
### 세컨더리 인덱스에 미치는 영향
- 세컨더리 인덱스는 레코드 주소를 가지고 있는게 아니라 pk 값을 가지고 있음
  - -> pk 키 바뀌면 주소가 바뀌어 버리기 때문에 pk 를 저장함.


### 클러스터링 인덱스의 장점과 단점
- 장점
  - PK 값으로 데이터를 찾기 때문에 빠르게 찾을 수 있음
  - 데이터를 읽을 때 순차적으로 읽을 수 있음
- 단점
  - PK 값이 바뀌면 데이터를 다시 정렬해야함
  - 세컨더리 인덱스 검색시 pk 키로 다시한번 검색해야 돼서 성능이 느림

### 클러스터링 테이블 주의 사항
1. pk 키가 커지면 세컨더리 데이터 크기도 커짐
2. auto-increment 보다는 업무적 생성 가능한 컬럼으로
3. pk 키는 반드시 설정할걸
4. 세컨더리 인덱스가 있는 경우 auto-increment도 좋음

## 9. 유니크 인덱스
- 유니크 제약 조건 걸면 자동으로 인덱스도 생성됨
### 유니크 인덱스와 일반 세컨더리 인덱스 비교 
1. 인덱스 읽기
   - 세컨더리랑 성능 비슷함 = 비교는 유니크가 빠름 (1개만 읽고 멈추기 때문에)
2. 인덱스 쓰기
   - 유니크 조건을 검색해야 되기 때문에 쓰기 성능이 느림
   - 변경시 읽기 잠금 + 쓰기 잠금이라 데드락 발생 가능성 높음
3. 유니크 인덱스 사용 시 주의 사항
   - 쓰기 성능 하락이 있으므로 꼭 필요한 경우가 아니면 사용하지 않는 것이 좋음
   - 유니크를 걸면 인덱스가 자동 생성되므로 인덱스를 중복으로 생성하지 않도록 주의 해야함.

## 10. 외래키
- 외래키는 인덱스를 자동으로 생성함
- 외래키가 제거되지 않으면 인덱스를 제거할 수 없음
1. 자식 테이블이 부모 때문에 대기하는 경우
   - 부모 테이블에 레코드락이 걸려있을 때 자식의 fk 값을 해당 부모의 값으로 set할 때 대기함
   - fk 키를 건드리는게 아니면 락 안걸림
2. 부모 테이블이 자식 때문에 대기하는 경우
   - 부모테이블 레코드를 삭제할때 해당 참조가 걸려있는 자식 테이블이 쓰기 락이 걸려있으면 자식 테이블 변경이 완료될때까지 대기함


Q. 질문
- 전문 검색 인덱스 vs 엘라스틱 서치
- 멀티 밸류 인덱스 vs mongo db 인덱스 
- pk 키는 어떻게 정하는게 좋을까?
