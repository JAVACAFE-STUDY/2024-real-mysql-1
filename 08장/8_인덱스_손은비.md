## 0. 들어가기 전에

-   데이터베이스 쿼리의 성능 부분에서 항사 언급되는 부분(쿼리 튜닝 기본)
-   각 인덱스의 특성과 차이는 상당히 중요하고, 물리 수준의 모델링을 할 때도 중요한 요소

## 1. 디스크 읽기 방식

DB의 성능 튜닝은 대부분 디스크 I/O를 줄이는 방향으로 이루어진다.

**1-1) 하드 디스크 드라이브(HDD), 솔리드 스레이트 드라이브(SSD)**

DBMS에선 랜덤 I/O가 대부분이므로 SSD가 좋다.

**1-2) 랜덤 I/O와 순차I/O**

랜덤 I/O, 순차 I/O 다 읽을 데이터의 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것

순차 I/O의 성능이 랜덤 I/O보다 좋다.

디스크 원판을 가지지 않는 SSD는 랜덤 I/O와 순차 I/O가 차이가 없을 것으로 예측하지만, 실제로는 그렇지 않다. SSD 드라이브에서도 랜덤 I/O는 여전히 순차 I/O보다 스루풋이 떨어진다.

그래서 SSD 사양에도 항상 순차 I/O와 랜덤 I/O의 성능 비교를 구분해서 명시한다.

## 2. 인덱스란?

-   DBMS에서 인덱스는 데이터의 쓰기 성능을 희생하고 읽기 성능을 높이는 기능이다.
-   인덱스를 하나 더 추가할지 말지는 데이터의 저장 속도를 어디까지 희생할 수 있는지, 읽기 속도를 얼마나 더 빠르게 만들어야 하는지를 결정해야 함
-   데이터 저장 방식(알고리즘) 별로 구분할 경우 상당히 많지만, 대표적으로 B-Tree 인덱스와 Hash 인덱스로 구분할 수 있다.

## 3. B-Tree 인덱스

가장 일반적으로 사용되는 인덱스 알고리즘으로, 상당히 오래전에 도입된 알고리즘이고, 그만큼 성숙하다. 가장 범용적인 알고리즘.

B-Tree 인덱스는 컬럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘이다.

MySQL 서버에서는 위치 기반 검색을 지원하기 위한 R-Tree 인덱스 알고리즘도 있지만, 결국 R-Tree 인덱스는 결국 B-Tree의 응용 알고리즘을 볼 수 있다.

**[구조 및 특성]**

![스크린샷 2024-10-24 오후 8.51.04.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/9f0c08f1-728e-42d2-bbf3-345b741ebfc9/1601dc10-ad39-4c6d-8d53-757f2b9c0dfc/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-10-24_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_8.51.04.png)

구성 : `루트 노드(페이지), 브렌치 노드(페이지), 리프 노드(페이지), 데이터파일`

인덱스의 키 값은 모두 정렬되어 있지만, 데이터 파일의 레코드는 정렬돼 있지 않고 임의의 순서로 저장돼 있다.

**[B-Tree 인덱스를 통한 데이터 읽기]**

-   인덱스 레인지 스캔
    검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식
-   인덱스 풀 스캔
    인덱스의 처음부터 끝까지 모두 읽는 방식
-   루스 인덱스 스캔
    느슨하게 듬성듬성하게 인덱스를 읽는 방식
-   인덱스 스킵 스캔
    다중 칼럼 인덱스에서 특정 칼럼에 대한 조건만으로 인덱스를 건너뛰며 검색하는 방식. 인덱스의 첫 번째 칼럼을 건너뛰고, 나머지 칼럼으로 검색을 수행할 때 사용
-   다중 칼럼 인덱스
    두 개 이상의 칼럼을 결합해 만든 인덱스. 특정한 쿼리에서 여러 칼럼을 동시에 조건으로 사용해야 할 때 성능을 높임

## 4. R-Tree 인덱스

기본적인 내부 매커니즘은 B-Tree와 흡사하다. B-Tree는 인덱스를 구성하는 컬럼의 값이 1차워의 스칼라 값인 반면, R-Tree 인덱스는 2차원의 공간 개념 값이다.

**[MySQL의 공간 데이터 타입]**

![스크린샷 2024-10-29 오후 6.34.03.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/9f0c08f1-728e-42d2-bbf3-345b741ebfc9/87cf1992-f352-4736-9c93-26bbf4b076e2/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-10-29_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_6.34.03.png)

공간 정보의 탐색을 위한 R-Tree 알고리즘을 이해하려면 MBR(해당 도형을 감싸는 최소 크기의 사각형)이라는 개념을 알고 있어야 한다. 이 사각형들의 포함 관계를 B-Tree 형태로 구현한 인덱스가 R-Tree 인덱스다. MBR 정보를 이용해 B-Tree 형태로 인덱스를 구축하므로 R과 B-Tree를 섞어서 R-Tree라는 이름이 붙여졌다.

## 5. 전문 검색(Full Text search) 인덱스

문서의 내용 전체를 인덱스화해서 특정 키워드가 포함된 문서를 검색하는 전문 검색에는 InnoDB나 MyISAM 스토리지 엔진에서 제공하는 일반적인 용도의 B-Tree 인덱스를 사용할 수 없다.

문서 전체에 대한 분석과 검색을 위한 이런 인덱싱 알고리즘은 전문 검색 인덱스라고 하는데, 전문 검색 인덱스는 일반화된 기능의 명칭이자 전문 검색 알고리즘의 이름을 지칭하는 것은 아니다.

전문 검색에서는 문서 본문의 내용에서 사용자가 검색하게 될 키워드를 분석해 내고, 빠른 검색용으로 사용할 수 있게 이러한 키워드로 인덱스를 구축한다. 전문 검색 인덱스는 문서의 키워드를 인덱싱하는 기법에 따라 크게 단어의 **어근 분석**과 **n-gram 분석 알고리즘**으로 구분할 수 있다.

**[어근 분석 알고리즘]**

불용어 처리 → 어근 분석을 거쳐 색인 작업이 수행된다.

불용어 처리 : 검색에서 별 가치가 없는 단어를 모두 필터링해서 제거하는 작업

어근 분석 : 검색어로 선정된 단어의 뿌리인 원형을 찾는 작업

**[n-gram 알고리즘]**

본문을 무조건 몇 글자씩 잘라서 인덱싱하는 방법이다.

ex) That → Th / ha / at

-   전문 검색 인덱스의 불용어 처리 무시 : `ft_stopword_file=’’`
-   사용자 정의 불용어 사용 : `ft_stopword_file=’/data/my_custom_stopword.txt’`

**[전문 검색 인덱스 사용 필요 조건]**

-   쿼리 문장이 전문 검색을 위한 문법(MATCH … AGAINST …)
-   테이블이 전문 검색 대상 컬럼에 대해서 전문 인덱스 보유

## 6. 함수 기반 인덱스

일반적인 인덱스는 컬럼의 값 일부 또는 전체에 대해서만 인덱스 생성이 허용된다.

하지만 때로는 컬럼의 값을 변형해서 만들어진 값에 대해 인덱스를 구축해야 할 때도 있는데, 이러한 경우 함수 기반의 인덱스를 활용하면 된다.

MySQL 8.0 버전부터는 테이블의 구조를 변경하지 않고, 함수를 직접 사용하는 인덱스를 생성할 수 있게 됐다.

함수를 직접 사용하는 인덱스는 테이블의 구조는 변경하지 않고, 계산된 결과값의 검색을 빠르게 만들어준다.

함수 기반 인덱스를 제대로 활용하려며 반드시 조건절에 함수 기반 인덱스에 명시된 표현식이 그대로 사용돼야 한다.

## 7. 멀티 밸류(Multi-Value) 인덱스

인덱스 키와 데이터 레코드는 1:1의 관계를 가진다. 멀티 밸류 인덱스란 하나의 데이터 레코드가 여러 개의 키 값을 가질 수 있는 형태의 인덱스

일반적인 RDBMS를 기준으로 생각하면 정규화에 위배되는 형태. 하지만 최근 RDBMS들이 JSON 데이터 타입을 지원하기 시작하면서 JSON 배열 타입의 필드에 저장된 원소들에 대한 인덱스 요건이 발생한 것이다.

## 8. 클러스터링 인덱스

MySQL 서버에서 클러스터링은 테이블의 레코들르 비슷한 것(프라이머리 키를 기준)들끼리 묶어서 저장하는 형태로 구현한다. 이는 주로 비슷한 값들을 동시에 조회하는 경우가 많다는 점에서 착안한 것이다.

**클러스터링 인덱스는 PK에 대해서만 적용되는 내용이다.** PK값이 변경되면, 레코드의 물리적인 저장위치도 바뀌어야 한다. 클러스터링 인덱스는 PK에 의해 레코드의 저장 위치가 결정되므로 사실 인덱스 알고리즘이라기보다 테이블 레코드의 저장 방식이라고 볼 수 있다.

“클러스터링 인덱스” 와 “클러스터링 테이블”은 동의어로 사용되기도 한다.

클러스터링 테이블은 그 자체로 하나의 거대한 인덱스 구조로 관리된다.

**[장점과 단점]**

-   장점
    -   PK로 검색할 때 처리가 매우 빠름
    -   테이블의 모든 세컨더리 인덱스가 PK를 가지고 있으므로 인덱스만으로 처리할 수 있는 경우가 많음
-   단점
    -   테이블의 모든 세컨더리 인덱스가 클러스터링 키를 갖기 때문에 클러스터링 키 값의 크기가 클 경우 전체적으로 인덱스의 크기가 커짐
    -   세컨더리 인덱스를 통해 검색할 때 PK로 한 번 더 검색해야 하므로 처리 성능 느림
    -   INSERT할 때 PK에 의해 레코드의 저장 위치가 결정되기 때문에 처리 성능 느림
    -   PK 변경 시 레코드를 DELETE하고 INSERT하는 작업이 필요하기 때문에 처리 성능 느림

**[주의 사항]**

-   클러스터링 인덱스 키의 크기
-   PK는 AUTO_INCREMENT 보다 업무적 컬럼으로 생성
-   PK는 반드시 명시

\*\* PK를 대체하기 위해 인위적으로 추가된 PK를 인조 식별자라고 하는데, 세컨더리 인덱스도 필요하고 PK 크기도 길다면 AUTO_INCREMENT 컬럼을 인조 식별자로 사용하자

## 9. 유니크 인덱스

유니크 인덱스는 제약 조건에 가깝다고 볼 수 있다.

말 그대로 테이블이나 인덱스에 같은 값이 2개 이상 저장될 수 없음을 의미하는데, MySQL에서는 인덱스 없이 유니크 제약만 설정할 수 없다.

**[사용 시 주의사항]**

-   성능이 좋아질 것으로 생각하고 불필요한 유니크 인덱스는 생성하지 않는 것이 좋다.
-   중복해서 생성하지 말기
-   유일성이 꼭 보장돼야 하는 컬럼에 대해서는 유니크 인덱스를 생성하되, 꼭 필요하지 않다면 유니크 인덱스보다는 세컨더리 인덱스를 생성하기

## 10. 외래키

MySQL에서 외래키는 InnoDB 스토리지 엔진에서만 생성할 수 있으며, 외래키 제약이 설정되면 자동으로 연관되는 테이블의 컬럼에 인덱스까지 생성된다. 외래키가 제거되지 않은 상태에서는 자동으로 생성된 인덱스를 삭제할 수 없다.

**[InnoDB 외래키 특징]**

-   테이블 변경(쓰기 잠금)이 발생하는 경우에만 잠금 경합(잠금 대기)이 발생
-   외래키와 연관되지 않은 컬럼의 변경은 최대한 잠금 경합(잠금 대기)을 발생시키지 않음
