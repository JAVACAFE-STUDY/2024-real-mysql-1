## 0. 들어가기 전에

-   데이터베이스 쿼리의 성능 부분에서 항사 언급되는 부분(쿼리 튜닝 기본)
-   각 인덱스의 특성과 차이는 상당히 중요하고, 물리 수준의 모델링을 할 때도 중요한 요소

## 1. 디스크 읽기 방식

DB의 성능 튜닝은 대부분 디스크 I/O를 줄이는 방향으로 이루어진다.

**1-1) 하드 디스크 드라이브(HDD), 솔리드 스레이트 드라이브(SSD)**

DBMS에선 랜덤 I/O가 대부분이므로 SSD가 좋다.

**1-2) 랜덤 I/O와 순차I/O**

랜덤 I/O, 순차 I/O 다 읽을 데이터의 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것

순차 I/O의 성능이 랜덤 I/O보다 좋다.

디스크 원판을 가지지 않는 SSD는 랜덤 I/O와 순차 I/O가 차이가 없을 것으로 예측하지만, 실제로는 그렇지 않다. SSD 드라이브에서도 랜덤 I/O는 여전히 순차 I/O보다 스루풋이 떨어진다.

그래서 SSD 사양에도 항상 순차 I/O와 랜덤 I/O의 성능 비교를 구분해서 명시한다.

## 2. 인덱스란?

-   DBMS에서 인덱스는 데이터의 쓰기 성능을 희생하고 읽기 성능을 높이는 기능이다.
-   인덱스를 하나 더 추가할지 말지는 데이터의 저장 속도를 어디까지 희생할 수 있는지, 읽기 속도를 얼마나 더 빠르게 만들어야 하는지를 결정해야 함
-   데이터 저장 방식(알고리즘) 별로 구분할 경우 상당히 많지만, 대표적으로 B-Tree 인덱스와 Hash 인덱스로 구분할 수 있다.

## 3. B-Tree 인덱스

가장 일반적으로 사용되는 인덱스 알고리즘으로, 상당히 오래전에 도입된 알고리즘이고, 그만큼 성숙하다. 가장 범용적인 알고리즘.

B-Tree 인덱스는 컬럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘이다.

MySQL 서버에서는 위치 기반 검색을 지원하기 위한 R-Tree 인덱스 알고리즘도 있지만, 결국 R-Tree 인덱스는 결국 B-Tree의 응용 알고리즘을 볼 수 있다.

**[구조 및 특성]**

![스크린샷 2024-10-24 오후 8.51.04.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/9f0c08f1-728e-42d2-bbf3-345b741ebfc9/1601dc10-ad39-4c6d-8d53-757f2b9c0dfc/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-10-24_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_8.51.04.png)

구성 : `루트 노드(페이지), 브렌치 노드(페이지), 리프 노드(페이지), 데이터파일`

인덱스의 키 값은 모두 정렬되어 있지만, 데이터 파일의 레코드는 정렬돼 있지 않고 임의의 순서로 저장돼 있다.

**[B-Tree 인덱스를 통한 데이터 읽기]**

-   인덱스 레인지 스캔
    검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식
-   인덱스 풀 스캔
    인덱스의 처음부터 끝까지 모두 읽는 방식
-   루스 인덱스 스캔
    느슨하게 듬성듬성하게 인덱스를 읽는 방식
-   인덱스 스킵 스캔
    다중 칼럼 인덱스에서 특정 칼럼에 대한 조건만으로 인덱스를 건너뛰며 검색하는 방식. 인덱스의 첫 번째 칼럼을 건너뛰고, 나머지 칼럼으로 검색을 수행할 때 사용
-   다중 칼럼 인덱스
    두 개 이상의 칼럼을 결합해 만든 인덱스. 특정한 쿼리에서 여러 칼럼을 동시에 조건으로 사용해야 할 때 성능을 높임

## 4. R-Tree 인덱스

## 5. 전문 검색(Full Text search) 인덱스

## 6. 함수 기반 인덱스

## 7. 멀티 밸류(Multi-Value) 인덱스

## 8. 클러스터링 인덱스

## 9. 유니크 인덱스

## 10. 외래키
