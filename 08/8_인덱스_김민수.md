## 인덱스란?

많은 사람들이 인덱스를 언급할 때 책의 맨 끝에 있는 찾아보기(색인)로 설명한다.
책의 마지막에 있는 찾아보기가 인덱스에 비유된다면 책의 내용은 데이터 파일에 해당한다고 볼 수 있다.
책의 찾아보기를 통해 알아낼 수 있는 페이지 번호는 데이터 파일에 저장된 레코드의 주소에 비유될 것이다.
DBMS 또한 테이블의 모든 데이터를 검색해서 원하는 결과를 가져오려면 시간이 오래 걸리기 때문에 칼럼(또는 칼럼들)의 값과 해당 레코드가 저장된 주소를 Key-Value로 인게스를 만들어 둔다.
또한 인덱스는 중요한 것이 정렬이 된 상태를 유지해야 한다.
때문에 인덱스가 많은 테이블은 INSERT, DELETE, UPDATE 와 같은 쿼리의 처리가 느려진다.
즉 인덱스는 INSERT, UPDATE, DELETE의 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능이다.
SELECT 쿼리에 WHERE 조건에 사용되는 컬럼이라고 해서 전부 인덱스로 생성하면 데이터 저장 성능이 떨어지고 인덱스의 크기가 비대해져 오히려 역효과만 불러올 수 있다.

## B-Tree

B-Tree 알고리즘은 가장 일반적으로 사용되는 인덱스 알고리즘으로, 상당히 오래전부터 도입됐으며 그만큼 성숙하다.
B-Tree 인덱스는 컬럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱한다.
그 외 위치 기반 검색을 지원하기 위한 R-Tree 알고리즘도 있지만, R-Tree 인덱스는 B-Tree 알고리즘의 응용으로 볼 수 있다.

## B-Tree 인덱스 키 추가 및 삭제

인덱스 키 추가
새로운 키 값이 B-Tree에 저장될 때 테이블의 스토리지 엔진에 따라 새로운 키 값이 즉시 인덱스에 저장될 수도 있고 그렇지 않을 수도 있다.

B-Tree에 저장될 때는 저장될 키 값을 이용해 B-Tree상 적절한 위치를 검색하고, 저장될 위치가 결정되면 레코드의 키 값과 대상 레코드의 주소 정보를 B-Tree의 리프 노드에 저장한다.

리프 노드가 꽉 차서 저장할 수 없을 때는 리프 노드가 분리돼야 하는데, 이는 상위 브랜치 노드까지 처리의 범위가 넓어진다.
따라서 B-Tree는 상대적으로 쓰기 작업에 비용이 많이 든다.

## 인덱스 키 삭제

B-Tree의 키 값이 삭제되는 경우는 간단한데, 해당 키 값이 저장된 B-Tree 리프 노드를 찾아서 그냥 삭제 마크만 하면 작업이 완료된다.

이렇게 삭제 마킹된 인덱스 키 공간은 계속 그대로 방치하거나 재활용할 수 있다.

인덱스 키 삭제로 인한 마킹 작업 또는 디스크 쓰기가 필요하므로 이 작업 역시 디스크 I/O가 발생한다.

이 작업 또한 체인지 버퍼를 통해 최적화되어 처리 된다.

## 인덱스 키 변경

인덱스 키 값은 그 값에 따라 저장될 리프 노드의 위치가 결정되므로 B-Tree의 키 값이 변경되는 경우는 단순히 인덱스 상의 키 값만 변경하는 것은 불가능하다.

따라서 단순히 키 값을 삭제한 후, 다시 새로운 키를 추가하는 형태로 처리된다.

따라서 이 작업 또한 체인지 버퍼를 통해 최적화되어 처리 된다.

## 인덱스 키 검색

INSERT, UPDATE, DELETE 작업을 할 때 인덱스 관리에 따르는 오버헤드를 감당하며 인덱스를 구축하는 이유는 바로 빠른 검색을 위해서이다.

인덱스를 검색하는 작업은 B-Tree의 루트 노드부터 시작해서 브랜치 노드를 거쳐 최종으로 리프 노드까지 이동하며 비교 작업을 수행하는데 이를 트리 탐색이라고 한다.

## B-Tree 인덱스 사용에 영향을 미치는 요소

B-Tree 인덱스는 인덱스를 구성하는 컬럼의 크기와 레코드의 건수, 그리고 유니크한 인덱스 키 값의 개수 등에 의해 검색이나 변경 작업의 성능이 영향 받는다.
인덱스 트리 탐색은 SELECT 뿐 아니라 UPDATE, DELETE를 처리하기 위해 항상 레코드를 먼저 검색해야 할 경우에도 사용된다.

## B-Tree 인덱스를 통한 데이터 읽기

어떤 경우에 인덱스를 사용할 지, 사용하지 않을 지를 판단하려면 MySQL(더 정확히는 스토리지 엔진)이 어떻게 인덱스를 이용해서 실제 레코드를 읽는지 알아야 한다.

## 인덱스 레인지 스캔

인덱스 레인지 스캔은 인덱스의 접근 방법 중 가장 대표적인 접근 방식으로, 뒤에서 설명할 나머지 접근 방식보다 빠른 방법이다.
인덱스를 통해 레코드를 한 건만 읽는 경우와 한 건 이상을 읽는 경우를 각각 다른 이름으로 구분하지만, 책에서는 인덱스 레인지 스캔이라고 표현했다.

## 인덱스 풀 스캔

인덱스 레인지 스캔과 마찬가지로 인덱스를 사용하지만 인덱스 레인지 스캔과 달리 인덱스의 처음부터 끝까지 모두 읽는 방식을 인덱스 풀 스캔이라고 한다.

## 다중 컬럼 인덱스

인덱스는 하나의 컬럼으로 사용할 수 있는게 아니라, 다중 컬럼으로도 사용할 수 있다.

## R-Tree 인덱스

MySQL의 공간 인덱스는 R-Tree 인덱스 알고리즘을 통해 2차원의 데이터를 인덱싱하고 검색하는 목적의 인덱스다.
이러한 인덱스를 다중 컬럼 인덱스 또는 복합 컬럼 인덱스라고 한다.
인덱스 풀 스캔은 조건절에 사용된 컬럼이 인덱스의 첫 번째 컬럼이 아닌 경우 인덱스 풀 스캔이 사용된다.

## 전문 검색(Full Text search) 인덱스

지금까지 살펴본 인덱스 알고리즘
일반적으로 크지 않은 데이터 또는 이미 키워드화한 작은 값에 대한 인덱싱 알고리즘

전문 검색이란?

문서의 내용 전체를 인덱스화해서 특정 키워드가 포함된 문서를 검색하는 것
InnoDB나 MyISAM 스토리지 엔진에서 제공하는 일반적인 용도의 B-Tree 인덱스를 사용할 수 없음
문서 전체에 대한 분석과 검색을 위한 인덱싱 알고리즘을 전문 검색 인덱스라고 함

## 멀티 밸류(Multi-Value) 인덱스

전문 검색 인덱스를 제외한 모든 인덱스
레코드 1건이 1개의 인덱스 키 값을 가짐

## 클러스터링 인덱스

테이블의 프라이머리 키에 대해서만 적용되는 내용
프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것을 클러스터링 인덱스라고 표현

즉, 인덱스 키와 데이터 레코드는 1:1의 관계
